<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" /> 
    <title>CS 544: Homework 1 Solution</title>
    <link href="hw1-sol/hl-fine_blue.css" rel="stylesheet"/><link href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" 
       rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script>    

  </head>
  <body>
    <nav>
      <ul>
	<li><a href="../../index.html" class="material-icons">house</a></li>
	<li><a href="../../docs/index.html">Docs</a></li>
	<li><a href="../../exercises/index.html">Exercises</a></li>
	<li><a href="../../hws/index.html">Homeworks</a></li>
	<li><a href="../../misc/index.html">Misc</a></li>
	<li><a href="../../projects/index.html">Projects</a></li>
	<li><a href="../../slides/index.html">Slides</a></li>
	<li><a id="loginAction"></a></li>
      </ul>
    </nav>
    <div class="content">
      <section data-coord="hw1-sol.umt:1:0"><h1 data-coord="hw1-sol.umt:1:0">Homework 1 Solution</h1><p data-coord="hw1-sol.umt:3:0"><strong data-coord="hw1-sol.umt:3:0">Due Date</strong>: Jun 11 by 11:59p;
</p><p data-coord="hw1-sol.umt:5:0">To be turned in as <strong data-coord="hw1-sol.umt:5:19">PDF</strong> via submission link on mycourses.  To facilitate
grading, please also add a <samp data-coord="hw1-sol.umt:5:101">hw1.js</samp> executable file for Questions 1 - 13.
</p><p data-coord="hw1-sol.umt:8:0"><strong data-coord="hw1-sol.umt:8:0">Important Reminder</strong>: As per the course
<em data-coord="hw1-sol.umt:8:110"><a href="../../misc/academic-honesty-statement/academic-honesty-policy.html" data-coord="hw1-sol.umt:8:110">Academic Honesty Statement</a></em>, cheating of any kind will minimally
result in your letter grade for the entire course being reduced by one
level.
</p><p data-coord="hw1-sol.umt:14:0">Please remember to justify all answers.
</p><p data-coord="hw1-sol.umt:16:0">Note that some of the questions require you to show code.  You may use
a JavaScript implementation to verify your answers.
</p><p data-coord="hw1-sol.umt:19:0">You are encouraged to use the web or the library but are <strong data-coord="hw1-sol.umt:19:57">required</strong> to
cite any external sources used in your answers.
</p><p data-coord="hw1-sol.umt:22:0"><strong data-coord="hw1-sol.umt:22:0">It may be the case that some questions cannot be answered as
 requested.</strong>
</p><p data-coord="hw1-sol.umt:25:0">Many of the questions are meant to familiarize you with the built-in
functions available in JavaScript (and many other languages) for
arrays and strings. 
</p><p data-coord="hw1-sol.umt:30:0"><strong data-coord="hw1-sol.umt:30:0">Notes</strong>:
</p><ul data-coord="hw1-sol.umt:32:0"><li data-coord="hw1-sol.umt:32:0"><p data-coord="hw1-sol.umt:32:4">We use <samp data-coord="hw1-sol.umt:32:11">C:fn()</samp> to refer to <samp data-coord="hw1-sol.umt:32:32">C.prototype.fn()</samp>.
</p></li><li data-coord="hw1-sol.umt:34:0"><p data-coord="hw1-sol.umt:34:4">A <strong data-coord="hw1-sol.umt:34:6">word</strong> is defined to be a maximal contiguous sequence of
non-whitespace characters. 
</p></li></ul><p id="restrict" data-coord="hw1-sol.umt:37:0"><strong data-coord="hw1-sol.umt:37:0">Restrictions</strong> </p><p data-coord="hw1-sol.umt:39:0">Some of the questions specify "Subject to the above restrictions".
These restrictions are to force you to write code in a <strong data-coord="hw1-sol.umt:39:123">strictly</strong>
functional style without any
<a href="https://en.wikipedia.org/wiki/Immutable_object" data-coord="hw1-sol.umt:39:213">mutation.</a>  The
specific restrictions are:
</p><ul data-coord="hw1-sol.umt:45:0"><li data-coord="hw1-sol.umt:45:0"><p data-coord="hw1-sol.umt:45:4">Your code may not make any explicit use of destructive
assignment, iteration or recursion.
</p></li><li data-coord="hw1-sol.umt:48:0"><p data-coord="hw1-sol.umt:48:4">You code may not contain any <samp data-coord="hw1-sol.umt:48:33">let</samp> or <samp data-coord="hw1-sol.umt:48:42">var</samp> declarations.
</p></li><li data-coord="hw1-sol.umt:50:0"><p data-coord="hw1-sol.umt:50:4">The answer provided for a specific question may contain
only a <strong data-coord="hw1-sol.umt:50:71">single</strong> top-level function.
</p></li></ul><p data-coord="hw1-sol.umt:53:0">What you are allowed to do:
</p><ul data-coord="hw1-sol.umt:55:0"><li data-coord="hw1-sol.umt:55:0"><p data-coord="hw1-sol.umt:55:4">Your code may declare <code><span class="hl kwb">const</span></code> variables with an initializer.
</p></li><li data-coord="hw1-sol.umt:57:0"><p data-coord="hw1-sol.umt:57:4">A function provided for a particular answer may call a function
defined in an earlier answer.
</p></li><li data-coord="hw1-sol.umt:60:0"><p data-coord="hw1-sol.umt:60:4">You may also use the full power of JavaScript
<em data-coord="hw1-sol.umt:60:143"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" data-coord="hw1-sol.umt:60:143">regular expressions</a></em> for functions involving manipulating text.
</p></li><li data-coord="hw1-sol.umt:64:0"><p data-coord="hw1-sol.umt:64:4">You may use any
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" data-coord="hw1-sol.umt:64:119">String,</a>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" data-coord="hw1-sol.umt:64:226">RegExp,</a>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" data-coord="hw1-sol.umt:64:332">Array</a> or
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" data-coord="hw1-sol.umt:64:440">Number</a> or
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" data-coord="hw1-sol.umt:64:547">Math</a> functions which are used only for their return value and not
for any side-effects.  So for example, you may use
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" data-coord="hw1-sol.umt:64:774">Array:reverse()</a> if you are only using its return value and not for
its side-effect of changing its argument.  
</p></li></ul><p data-coord="hw1-sol.umt:81:0">Some hints for writing code subject to the above restrictions:
</p><ul data-coord="hw1-sol.umt:83:0"><li data-coord="hw1-sol.umt:83:0"><p data-coord="hw1-sol.umt:83:4">In the absence of assignment and iteration, the only sequence of
statements you can write are a sequence of zero-or-more <code><span class="hl kwb">const</span></code>
declarations followed by a <samp data-coord="hw1-sol.umt:83:169">return</samp> statement, or an
<samp data-coord="hw1-sol.umt:83:199">if-then-else</samp> statements with the bodies of the <samp data-coord="hw1-sol.umt:83:248">then</samp> and <samp data-coord="hw1-sol.umt:83:259">else</samp>
subject to the same restrictions.
</p></li><li data-coord="hw1-sol.umt:89:0"><p data-coord="hw1-sol.umt:89:4">Instead of using <samp data-coord="hw1-sol.umt:89:21">if-then-else</samp> statements, you are strongly urged
to consider using conditional expressions involving the ternary
operator <samp data-coord="hw1-sol.umt:89:152">?:</samp>.
</p></li><li data-coord="hw1-sol.umt:93:0"><p data-coord="hw1-sol.umt:93:4">Use higher-order
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" data-coord="hw1-sol.umt:93:119">Array</a> functions to replace the use of iteration.
</p></li><li data-coord="hw1-sol.umt:97:0"><p data-coord="hw1-sol.umt:97:4">Note that the functions provided to many of the <samp data-coord="hw1-sol.umt:97:52">Array</samp> functions
like <samp data-coord="hw1-sol.umt:97:79">map()</samp> and <samp data-coord="hw1-sol.umt:97:91">reduce()</samp> take multiple arguments including
the current index of the element being operated on and the array
being operated on.
</p></li><li data-coord="hw1-sol.umt:102:0"><p data-coord="hw1-sol.umt:102:4">The <samp data-coord="hw1-sol.umt:102:8">Array.from()</samp> function may be useful for setting up
initial arrays.
</p></li><li data-coord="hw1-sol.umt:105:0"><p data-coord="hw1-sol.umt:105:4"><strong data-coord="hw1-sol.umt:105:4">Warning</strong>: One of the bad parts of JavaScript is that when
<samp data-coord="hw1-sol.umt:105:67">return</samp>'ing a value from a function, the expression representing
the returned value must start on the same line as the <samp data-coord="hw1-sol.umt:105:191">return</samp>
keyword.  So
</p><pre>    <span class="hl kwa">return</span>
      expr<span class="hl opt">;</span></pre><p data-coord="hw1-sol.umt:115:4">will return <samp data-coord="hw1-sol.umt:115:16">undefined</samp>, but
</p><pre>    <span class="hl kwa">return</span> expr<span class="hl opt">;</span></pre><p data-coord="hw1-sol.umt:121:4">or 
</p><pre>    <span class="hl kwa">return</span> <span class="hl opt">(</span>
      expr
    <span class="hl opt">);</span></pre><p data-coord="hw1-sol.umt:129:4">will work. 
</p></li><li data-coord="hw1-sol.umt:131:0"><p data-coord="hw1-sol.umt:131:4">To give you some idea of what is expected, here is a function
which returns an array containing the first <code>n</code> factorials:
</p><pre>    <span class="hl com">/** If n &gt; 0, return an array arr of length n such </span>
<span class="hl com">     *  that arr[i] === factorial(i + 1) for all i &lt; n</span>
<span class="hl com">     */</span>
    function <span class="hl kwd">factValues</span><span class="hl opt">(</span>n<span class="hl opt">) {</span> 
      <span class="hl kwa">return</span> Array<span class="hl opt">.</span><span class="hl kwd">from</span><span class="hl opt">({</span>length<span class="hl opt">:</span> n<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">}, (</span>_<span class="hl opt">,</span> i<span class="hl opt">) =&gt;</span> i <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">).</span>
        <span class="hl slc">//[2, 3, 4, ..., n]</span>
        <span class="hl kwd">reduce</span><span class="hl opt">((</span>acc<span class="hl opt">,</span> e<span class="hl opt">,</span> i<span class="hl opt">) =&gt;</span> acc<span class="hl opt">.</span><span class="hl kwd">concat</span><span class="hl opt">([</span>e <span class="hl opt">*</span> acc<span class="hl opt">[</span>i<span class="hl opt">]]),</span>
               <span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>  <span class="hl slc">//[1, 1*2, 1*2*3, ...,  1*2*3*...*n]</span>
    <span class="hl opt">}</span></pre><p data-coord="hw1-sol.umt:146:4">We create an initial array of length n - 1 with initial values \(2
    \ldots n\); we reduce these mapped indexes with an accumulator
(initialized to <code><span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]</span></code>) accumulating the values with the next
value computed as the mapped index multiplied by the last value
accumulated so far.
</p><p data-coord="hw1-sol.umt:152:4">Note that instead of using <code>acc<span class="hl opt">[</span>i<span class="hl opt">]</span></code> to pick up the last acc
value, we could have used <code>acc<span class="hl opt">.</span><span class="hl kwd">slice</span><span class="hl opt">(-</span><span class="hl num">1</span><span class="hl opt">)[</span><span class="hl num">0</span><span class="hl opt">]</span></code> instead.

</p></li></ul><ol data-coord="hw1-sol.umt:156:0"><li data-coord="hw1-sol.umt:156:0"><p data-coord="hw1-sol.umt:156:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:156:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:156:81">max(nums)</samp> which when given a non-empty list <samp data-coord="hw1-sol.umt:156:127">nums</samp> of
numbers, returns the maximum value in <samp data-coord="hw1-sol.umt:156:179">nums</samp>.
</p><p data-coord="hw1-sol.umt:160:4"><strong data-coord="hw1-sol.umt:160:4">Hint</strong>: Use
 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" data-coord="hw1-sol.umt:160:121">Array::sort().</a>  <em data-coord="hw1-sol.umt:160:137">4-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">max</span><span class="hl opt">([</span><span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">])</span>
    <span class="hl num">7</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">max</span><span class="hl opt">([</span><span class="hl num">4</span><span class="hl opt">])</span>
    <span class="hl num">4</span>
    <span class="hl kwd">max</span><span class="hl opt">([-</span><span class="hl num">1.2</span><span class="hl opt">, -</span><span class="hl num">0.8</span><span class="hl opt">, -</span><span class="hl num">2.4</span><span class="hl opt">])</span>
    <span class="hl opt">-</span><span class="hl num">0.8</span>
    <span class="hl opt">&gt;</span></pre><p data-coord="hw1-sol.umt:174:4">Simply return the last element of the sorted array.  We use
Array.from() to ensure that <samp data-coord="hw1-sol.umt:174:96">sort()</samp>'s changing its argument
does not change the parameter to <samp data-coord="hw1-sol.umt:174:166">max()</samp> (not changing parameters
was not specified in the restrictions but would definitely be
in the spirit of the restrictions).
</p><pre>    function <span class="hl kwd">max</span><span class="hl opt">(</span>nums<span class="hl opt">) {</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>nums<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> Array<span class="hl opt">.</span><span class="hl kwd">from</span><span class="hl opt">(</span>nums<span class="hl opt">).</span><span class="hl kwd">sort</span><span class="hl opt">((</span>a<span class="hl opt">,</span> b<span class="hl opt">) =&gt;</span> a <span class="hl opt">-</span> b<span class="hl opt">)[</span>nums<span class="hl opt">.</span>length <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">];</span>    
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:187:0"><p data-coord="hw1-sol.umt:187:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:187:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:187:81">average(nums)</samp> which when given a non-empty list <samp data-coord="hw1-sol.umt:187:131">nums</samp> of
numbers, returns the average of the values in <samp data-coord="hw1-sol.umt:187:191">nums</samp>. <em data-coord="hw1-sol.umt:187:199">4-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">average</span><span class="hl opt">( [</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">6</span> <span class="hl opt">])</span>
    <span class="hl num">3</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">average</span><span class="hl opt">( [</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span> <span class="hl opt">])</span>
    <span class="hl num">2.2</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">average</span><span class="hl opt">( [</span><span class="hl num">11.2</span><span class="hl opt">])</span>
    <span class="hl num">11.2</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:201:4">Simply use <samp data-coord="hw1-sol.umt:201:15">reduce()</samp> to compute the sum and then compute the average.
</p><pre>    function <span class="hl kwd">average</span><span class="hl opt">(</span>nums<span class="hl opt">) {</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>nums<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
      <span class="hl kwb">const</span> sum <span class="hl opt">=</span> nums<span class="hl opt">.</span><span class="hl kwd">reduce</span><span class="hl opt">((</span>acc<span class="hl opt">,</span> v<span class="hl opt">) =&gt;</span> acc <span class="hl opt">+</span> v<span class="hl opt">);</span>
      <span class="hl kwa">return</span> sum<span class="hl opt">/</span>nums<span class="hl opt">.</span>length<span class="hl opt">;</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:212:0"><p data-coord="hw1-sol.umt:212:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:212:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:212:81">linMax(nums)</samp> which when given a non-empty list <samp data-coord="hw1-sol.umt:212:130">nums</samp>
of numbers, returns the maximum value in <samp data-coord="hw1-sol.umt:212:182">nums</samp>.  The
performance of <samp data-coord="hw1-sol.umt:212:214">linMax()</samp> must be \(O(n)\) where \(n\) is the
length of <samp data-coord="hw1-sol.umt:212:273">nums</samp>. <em data-coord="hw1-sol.umt:212:281">5-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">linMax</span><span class="hl opt">([</span><span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">])</span>
    <span class="hl num">7</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">linMax</span><span class="hl opt">([</span><span class="hl num">4</span><span class="hl opt">])</span>
    <span class="hl num">4</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">linMax</span><span class="hl opt">([-</span><span class="hl num">1.2</span><span class="hl opt">, -</span><span class="hl num">0.8</span><span class="hl opt">, -</span><span class="hl num">2.4</span><span class="hl opt">])</span>
    <span class="hl opt">-</span><span class="hl num">0.8</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:228:4">Simply use <samp data-coord="hw1-sol.umt:228:15">reduce()</samp>.  Since <samp data-coord="hw1-sol.umt:228:34">nums</samp> is guaranteed to be non-empty,
there is no problem initializing the <samp data-coord="hw1-sol.umt:228:113">reduce()</samp> accumulator argument
with a <strong data-coord="hw1-sol.umt:228:156">minimum</strong> value.
</p><pre>    function <span class="hl kwd">linMax</span><span class="hl opt">(</span>nums<span class="hl opt">) {</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>nums<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> nums<span class="hl opt">.</span><span class="hl kwd">reduce</span><span class="hl opt">((</span>acc<span class="hl opt">,</span> e<span class="hl opt">) =&gt;</span> e <span class="hl opt">&gt;</span> acc <span class="hl opt">?</span> e <span class="hl opt">:</span> acc<span class="hl opt">);</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:239:0"><p data-coord="hw1-sol.umt:239:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:239:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:239:81">maxAbs(nums)</samp> which when given a non-empty list <samp data-coord="hw1-sol.umt:239:130">nums</samp>
of numbers, returns the maximum absolute value in
<samp data-coord="hw1-sol.umt:239:195">nums</samp>. <em data-coord="hw1-sol.umt:239:203">4-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">maxAbs</span><span class="hl opt">([</span><span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">])</span>
    <span class="hl num">7</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">maxAbs</span><span class="hl opt">([</span><span class="hl num">4</span><span class="hl opt">])</span>
    <span class="hl num">4</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">maxAbs</span><span class="hl opt">([-</span><span class="hl num">1.2</span><span class="hl opt">, -</span><span class="hl num">0.8</span><span class="hl opt">, -</span><span class="hl num">2.4</span><span class="hl opt">])</span>
    <span class="hl num">2.4</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:254:4">Simply map the list using <samp data-coord="hw1-sol.umt:254:30">Math.abs()</samp>, sort and return last element.
</p><pre>     function <span class="hl kwd">maxAbs</span><span class="hl opt">(</span>nums<span class="hl opt">) {</span>
       <span class="hl kwa">assert</span><span class="hl opt">(</span>nums<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
       <span class="hl kwa">return</span> nums<span class="hl opt">.</span>
         <span class="hl kwd">map</span><span class="hl opt">(</span>v <span class="hl opt">=&gt;</span> Math<span class="hl opt">.</span><span class="hl kwd">abs</span><span class="hl opt">(</span>v<span class="hl opt">)).</span>
         <span class="hl kwd">sort</span><span class="hl opt">((</span>a<span class="hl opt">,</span> b<span class="hl opt">) =&gt;</span> a <span class="hl opt">-</span> b<span class="hl opt">)</span>
         <span class="hl opt">[</span>nums<span class="hl opt">.</span>length <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">];</span>
     <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:266:0"><p data-coord="hw1-sol.umt:266:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:266:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:266:81">median(nums)</samp> which when given a non-empty list <samp data-coord="hw1-sol.umt:266:130">nums</samp>
of numbers, returns the <a href="https://en.wikipedia.org/wiki/Median" data-coord="hw1-sol.umt:266:209">median</a> of <samp data-coord="hw1-sol.umt:266:219">nums</samp>. <em data-coord="hw1-sol.umt:266:227">5-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">median</span><span class="hl opt">([</span><span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">9</span><span class="hl opt">,</span> <span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">6</span><span class="hl opt">])</span>
    <span class="hl num">6</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">median</span><span class="hl opt">([</span><span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">6</span><span class="hl opt">,</span> <span class="hl num">9</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">, ])</span>
    <span class="hl num">4.5</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">median</span><span class="hl opt">([</span><span class="hl num">8</span><span class="hl opt">, ])</span>
    <span class="hl num">8</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">median</span><span class="hl opt">([</span><span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">2</span> <span class="hl opt">])</span>
    <span class="hl num">5</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">median</span><span class="hl opt">([</span><span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">])</span>
    <span class="hl num">3</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">median</span><span class="hl opt">([</span><span class="hl num">1.4</span><span class="hl opt">,</span> <span class="hl num">2.4</span><span class="hl opt">])</span>
    <span class="hl num">1.9</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:287:4">Sort <samp data-coord="hw1-sol.umt:287:9">nums</samp> and then pick up the median as the middle element when
<samp data-coord="hw1-sol.umt:287:75">nums</samp> contains an odd number of elements; the average of the two
middle elements when <samp data-coord="hw1-sol.umt:287:166">nums</samp> contains an even number of elements.
</p><pre>    function <span class="hl kwd">median</span><span class="hl opt">(</span>nums<span class="hl opt">) {</span>
      <span class="hl kwb">const</span> len <span class="hl opt">=</span> nums<span class="hl opt">.</span>length<span class="hl opt">;</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>len <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
      <span class="hl kwb">const</span> len2 <span class="hl opt">=</span> Math<span class="hl opt">.</span><span class="hl kwd">trunc</span><span class="hl opt">(</span>len<span class="hl opt">/</span><span class="hl num">2</span><span class="hl opt">);</span>
      <span class="hl kwb">const</span> sorted <span class="hl opt">=</span> nums<span class="hl opt">.</span><span class="hl kwd">sort</span><span class="hl opt">();</span>
      <span class="hl kwa">return</span> <span class="hl opt">(</span>len<span class="hl opt">%</span><span class="hl num">2</span> <span class="hl opt">===</span> <span class="hl num">1</span><span class="hl opt">)</span>
             <span class="hl opt">?</span> sorted<span class="hl opt">[</span>len2<span class="hl opt">]</span>
             <span class="hl opt">: (</span>sorted<span class="hl opt">[</span>len2 <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">] +</span> sorted<span class="hl opt">[</span>len2<span class="hl opt">])/</span><span class="hl num">2</span><span class="hl opt">;</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:303:0"><p data-coord="hw1-sol.umt:303:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:303:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:303:81">runs(ints)</samp> which when given a non-empty list <samp data-coord="hw1-sol.umt:303:128">ints</samp> of
integers, returns a list of runs of values <samp data-coord="hw1-sol.umt:303:185">ints</samp>.  Each run is
represented as a non-empty list of repeated numbers.  <em data-coord="hw1-sol.umt:303:264">6-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">runs</span><span class="hl opt">([</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">])</span>
    <span class="hl opt">[ [</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span> <span class="hl opt">], [</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span> <span class="hl opt">], [</span> <span class="hl num">3</span> <span class="hl opt">] ]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">runs</span><span class="hl opt">([</span><span class="hl num">1</span><span class="hl opt">,])</span>
    <span class="hl opt">[ [</span> <span class="hl num">1</span> <span class="hl opt">] ]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">runs</span><span class="hl opt">([</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">])</span>
    <span class="hl opt">[ [</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span> <span class="hl opt">], [</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span> <span class="hl opt">], [</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span> <span class="hl opt">], [</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span> <span class="hl opt">] ]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">runs</span><span class="hl opt">([ -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">,  -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, ])</span>
    <span class="hl opt">[ [ -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span> <span class="hl opt">], [ -</span><span class="hl num">3</span> <span class="hl opt">], [ -</span><span class="hl num">1</span> <span class="hl opt">], [ -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span> <span class="hl opt">] ]</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:320:4">Accumulate runs by comparing the current element with the run
being currently accumulated.
</p><pre>    function <span class="hl kwd">runs</span><span class="hl opt">(</span>ints<span class="hl opt">) {</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>ints<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
      <span class="hl kwb">const</span> extendRuns <span class="hl opt">= (</span>runs<span class="hl opt">,</span> val<span class="hl opt">) =&gt; {</span>
        <span class="hl kwb">const</span> lastRun <span class="hl opt">=</span> runs<span class="hl opt">.</span><span class="hl kwd">slice</span><span class="hl opt">(-</span><span class="hl num">1</span><span class="hl opt">)[</span><span class="hl num">0</span><span class="hl opt">];</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>lastRun<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
        <span class="hl kwa">return</span> <span class="hl opt">(</span>lastRun<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] ===</span> val<span class="hl opt">)</span>
               <span class="hl opt">?</span> runs<span class="hl opt">.</span><span class="hl kwd">slice</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">).</span><span class="hl kwd">concat</span><span class="hl opt">([</span>lastRun<span class="hl opt">.</span><span class="hl kwd">concat</span><span class="hl opt">([</span>val<span class="hl opt">])])</span>
               <span class="hl opt">:</span> runs<span class="hl opt">.</span><span class="hl kwd">concat</span><span class="hl opt">([[</span>val<span class="hl opt">]]);</span>
      <span class="hl opt">};</span>
      <span class="hl kwa">return</span> ints<span class="hl opt">.</span><span class="hl kwd">slice</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">).</span><span class="hl kwd">reduce</span><span class="hl opt">(</span>extendRuns<span class="hl opt">, [[</span>ints<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]]]);</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:338:0"><p data-coord="hw1-sol.umt:338:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:338:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:338:81">mode(ints)</samp> which when given a non-empty list <samp data-coord="hw1-sol.umt:338:128">ints</samp> of
integers, returns the
<a href="https://en.wikipedia.org/wiki/Mode_(statistics)" data-coord="hw1-sol.umt:338:219">mode</a> of
<samp data-coord="hw1-sol.umt:338:231">ints</samp>. If there are multiple modes values having equal counts,
then the largest value should be returned. <em data-coord="hw1-sol.umt:338:342">6-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">mode</span><span class="hl opt">([</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">])</span>
    <span class="hl num">3</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">mode</span><span class="hl opt">([</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">])</span>
    <span class="hl num">3</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">mode</span><span class="hl opt">([</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">])</span>
    <span class="hl num">2</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">mode</span><span class="hl opt">([</span> <span class="hl num">2</span><span class="hl opt">, ])</span>
    <span class="hl num">2</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">mode</span><span class="hl opt">([ -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">])</span>
    <span class="hl opt">-</span><span class="hl num">2</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">mode</span><span class="hl opt">([ -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">,  -</span><span class="hl num">2</span><span class="hl opt">])</span>
    <span class="hl opt">-</span><span class="hl num">2</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">mode</span><span class="hl opt">([ -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">, -</span><span class="hl num">3</span><span class="hl opt">,  -</span><span class="hl num">2</span><span class="hl opt">])</span>
    <span class="hl opt">-</span><span class="hl num">3</span></pre><p data-coord="hw1-sol.umt:362:4">Sort the list, compute runs and then return element having the
longest run.
</p><pre>    function <span class="hl kwd">mode</span><span class="hl opt">(</span>ints<span class="hl opt">) {</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>ints<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
      <span class="hl kwb">const</span> intsRuns <span class="hl opt">=</span> <span class="hl kwd">runs</span><span class="hl opt">(</span>ints<span class="hl opt">.</span><span class="hl kwd">sort</span><span class="hl opt">((</span>a<span class="hl opt">,</span> b<span class="hl opt">) =&gt;</span> a <span class="hl opt">-</span> b<span class="hl opt">));</span>
      <span class="hl kwb">const</span> sortedRuns <span class="hl opt">=</span> intsRuns<span class="hl opt">.</span><span class="hl kwd">sort</span><span class="hl opt">((</span>run1<span class="hl opt">,</span> run2<span class="hl opt">) =&gt; {</span>
        <span class="hl kwb">const</span> <span class="hl opt">[</span>len1<span class="hl opt">,</span> len2<span class="hl opt">] = [</span>run1<span class="hl opt">.</span>length<span class="hl opt">,</span> run2<span class="hl opt">.</span>length<span class="hl opt">];</span>
        <span class="hl kwa">return</span> len1 <span class="hl opt">===</span> len2 <span class="hl opt">?</span> run1<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] -</span> run2<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] :</span> len1 <span class="hl opt">-</span> len2<span class="hl opt">;</span>
      <span class="hl opt">});</span>
      <span class="hl kwa">return</span> sortedRuns<span class="hl opt">.</span><span class="hl kwd">slice</span><span class="hl opt">(-</span><span class="hl num">1</span><span class="hl opt">)[</span><span class="hl num">0</span><span class="hl opt">][</span><span class="hl num">0</span><span class="hl opt">];</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:377:0"><p data-coord="hw1-sol.umt:377:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:377:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:377:81">isDivisible(binStr, d)</samp> which when given a non-empty
binary string containing only <samp data-coord="hw1-sol.umt:377:169">0</samp> or <samp data-coord="hw1-sol.umt:377:176">1</samp> characters, returns
true iff the binary number specified by <samp data-coord="hw1-sol.umt:377:244">binStr</samp> is divisible
by positive integer <samp data-coord="hw1-sol.umt:377:290">d</samp>. <em data-coord="hw1-sol.umt:377:295">2-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">isDivisible</span><span class="hl opt">(</span><span class="hl str">&apos;1111&apos;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">)</span>
    <span class="hl kwa">true</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">isDivisible</span><span class="hl opt">(</span><span class="hl str">&apos;1111&apos;</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">)</span>
    <span class="hl kwa">false</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">isDivisible</span><span class="hl opt">(</span><span class="hl str">&apos;1100&apos;</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">)</span>
    <span class="hl kwa">true</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">isDivisible</span><span class="hl opt">(</span><span class="hl str">&apos;1100&apos;</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">)</span>
    <span class="hl kwa">true</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">isDivisible</span><span class="hl opt">(</span><span class="hl str">&apos;111&apos;</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">)</span>
    <span class="hl kwa">true</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:397:4">Trivial after using <samp data-coord="hw1-sol.umt:397:24">Number.parseInt()</samp> to convert from the binary
string to a number.
</p><pre>    function <span class="hl kwd">isDivisible</span><span class="hl opt">(</span>binStr<span class="hl opt">,</span> d<span class="hl opt">) {</span>
      <span class="hl kwa">return</span> Number<span class="hl opt">.</span><span class="hl kwd">parseInt</span><span class="hl opt">(</span>binStr<span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">) %</span> d <span class="hl opt">===</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:407:0"><p data-coord="hw1-sol.umt:407:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:407:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:407:81">words(text)</samp> which returns a list of all the words in
<samp data-coord="hw1-sol.umt:407:140">text</samp>.  For this and subsequent questions, a <strong data-coord="hw1-sol.umt:407:186">word</strong> is defined as
a maximal sequence of non-space characters. <em data-coord="hw1-sol.umt:407:255">2-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">words</span><span class="hl opt">(</span><span class="hl str">&apos;  twas brillig and</span><span class="hl esc">\n</span> <span class="hl str">the slithy</span><span class="hl esc">\n\t</span> <span class="hl str">toves &apos;</span><span class="hl opt">)</span>
    <span class="hl opt">[</span> <span class="hl str">&apos;twas&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;brillig&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;and&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;the&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;slithy&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;toves&apos;</span> <span class="hl opt">]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">words</span><span class="hl opt">(</span><span class="hl str">&apos;  twas &apos;</span><span class="hl opt">)</span>
    <span class="hl opt">[</span> <span class="hl str">&apos;twas&apos;</span> <span class="hl opt">]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">words</span><span class="hl opt">(</span><span class="hl str">&apos;  &apos;</span><span class="hl opt">)</span>
    <span class="hl opt">[]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">words</span><span class="hl opt">(</span><span class="hl str">&apos;&apos;</span><span class="hl opt">)</span>
    <span class="hl opt">[]</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:424:4">Simply use <samp data-coord="hw1-sol.umt:424:15">String:split()</samp> but need to take care of the fact
that <samp data-coord="hw1-sol.umt:424:75">split()</samp> can produce empty strings when splitting an empty
string.
</p><pre>    function <span class="hl kwd">words</span><span class="hl opt">(</span>text<span class="hl opt">) {</span>
      <span class="hl kwb">const</span> trimmed <span class="hl opt">=</span> text<span class="hl opt">.</span><span class="hl kwd">trim</span><span class="hl opt">();</span>
      <span class="hl kwa">return</span> trimmed<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span> <span class="hl opt">?</span> trimmed<span class="hl opt">.</span><span class="hl kwd">split</span><span class="hl opt">(/</span>\s<span class="hl opt">+/) : [];</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:435:0"><p data-coord="hw1-sol.umt:435:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:435:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:435:81">revWords(text)</samp> which returns string containing
all the words in text in reverse order.  The exact spelling of
whitespace in the return value must match the spelling of the
corresponding whitespace in <samp data-coord="hw1-sol.umt:435:295">text</samp>. <em data-coord="hw1-sol.umt:435:303">6-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">revWords</span><span class="hl opt">(</span>
       <span class="hl str">&apos;  twas brillig   and</span><span class="hl esc">\n</span> <span class="hl str">the slithy</span><span class="hl esc">\n\t</span> <span class="hl str">toves   &apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;  toves slithy   the</span><span class="hl esc">\n</span> <span class="hl str">and brillig</span><span class="hl esc">\n\t</span> <span class="hl str">twas   &apos;</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">revWords</span><span class="hl opt">(</span><span class="hl str">&apos;  &apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;  &apos;</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">revWords</span><span class="hl opt">(</span><span class="hl str">&apos;   twas &apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;   twas &apos;</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">revWords</span><span class="hl opt">(</span><span class="hl str">&apos;twas&apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;twas&apos;</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">revWords</span><span class="hl opt">(</span><span class="hl str">&apos;&apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;&apos;</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:456:4">Compute array of reversed words and array of whitespace and then merge
them together, being careful to ensure that whitespace segments are inserted
between the correct words.  Finally <samp data-coord="hw1-sol.umt:456:196">join()</samp> array together.
</p><pre>    function <span class="hl kwd">revWords</span><span class="hl opt">(</span>text<span class="hl opt">) {</span>
      <span class="hl kwb">const</span> trimmed <span class="hl opt">=</span> text<span class="hl opt">.</span><span class="hl kwd">trim</span><span class="hl opt">();</span>
      <span class="hl kwb">const</span> rev <span class="hl opt">=</span>
        <span class="hl opt">(</span>trimmed<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span> <span class="hl opt">?</span> trimmed<span class="hl opt">.</span><span class="hl kwd">split</span><span class="hl opt">(/</span>\s<span class="hl opt">+/) : []).</span>
        <span class="hl kwd">reverse</span><span class="hl opt">();</span>
      <span class="hl kwb">const</span> <span class="hl opt">[</span> leadSpace <span class="hl opt">] =</span> text<span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(/^</span>\s*/<span class="hl opt">);</span>      
      <span class="hl kwb">const</span> <span class="hl opt">[</span> trailSpace <span class="hl opt">] =</span>
        trimmed<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span> <span class="hl opt">?</span> text<span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(/</span>\s<span class="hl opt">*</span>$<span class="hl opt">/) :</span> <span class="hl str">&apos;&apos;</span><span class="hl opt">;</span>
      <span class="hl kwb">const</span> interSpaces <span class="hl opt">=</span> text<span class="hl opt">.</span><span class="hl kwd">trim</span><span class="hl opt">().</span>
        <span class="hl kwd">split</span><span class="hl opt">(/</span>\S<span class="hl opt">+/).</span>
        <span class="hl kwd">filter</span><span class="hl opt">(</span>space <span class="hl opt">=&gt;</span> space<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> <span class="hl opt">[</span>leadSpace<span class="hl opt">].</span>
        <span class="hl kwd">concat</span><span class="hl opt">(</span>rev<span class="hl opt">.</span><span class="hl kwd">slice</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">, -</span><span class="hl num">1</span><span class="hl opt">).</span>
               <span class="hl kwd">flatMap</span><span class="hl opt">((</span>w<span class="hl opt">,</span> i<span class="hl opt">) =&gt; [</span>w<span class="hl opt">,</span> interSpaces<span class="hl opt">[</span>i<span class="hl opt">]])).</span>
        <span class="hl kwd">concat</span><span class="hl opt">(</span>rev<span class="hl opt">.</span><span class="hl kwd">slice</span><span class="hl opt">(-</span><span class="hl num">1</span><span class="hl opt">)).</span>
        <span class="hl kwd">concat</span><span class="hl opt">([</span>trailSpace<span class="hl opt">]).</span>
        <span class="hl kwd">join</span><span class="hl opt">(</span><span class="hl str">&apos;&apos;</span><span class="hl opt">);</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:482:0"><p data-coord="hw1-sol.umt:482:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:482:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:482:81">wordCounts(text)</samp> which returns an object mapping each
distinct word in text to a count of the number of times it occurs
within text.  The keys of the return value should be sorted in
lexicographical order. Words which differ in case should be
treated as distinct.  You may assume that no word looks like an
integer.
</p><p data-coord="hw1-sol.umt:490:4"><strong data-coord="hw1-sol.umt:490:4">Hint</strong>: Since ES6, the non-integer keys of an object are
guaranteed to be sorted in insertion order. <em data-coord="hw1-sol.umt:490:109">5-points</em>
</p><pre>    <span class="hl kwd">wordCounts</span><span class="hl opt">(</span><span class="hl str">&apos; aaa bb aa bb aaa Aaa&apos;</span><span class="hl opt">)</span>
    <span class="hl opt">{</span> Aaa<span class="hl opt">:</span> <span class="hl num">1</span><span class="hl opt">,</span> aa<span class="hl opt">:</span> <span class="hl num">1</span><span class="hl opt">,</span> aaa<span class="hl opt">:</span> <span class="hl num">2</span><span class="hl opt">,</span> bb<span class="hl opt">:</span> <span class="hl num">2</span> <span class="hl opt">}</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">wordCounts</span><span class="hl opt">(</span><span class="hl str">&apos; aaa bb aa</span><span class="hl esc">\n\t</span><span class="hl str">bb aaa Aaa&apos;</span><span class="hl opt">)</span>
    <span class="hl opt">{</span> Aaa<span class="hl opt">:</span> <span class="hl num">1</span><span class="hl opt">,</span> aa<span class="hl opt">:</span> <span class="hl num">1</span><span class="hl opt">,</span> aaa<span class="hl opt">:</span> <span class="hl num">2</span><span class="hl opt">,</span> bb<span class="hl opt">:</span> <span class="hl num">2</span> <span class="hl opt">}</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">wordCounts</span><span class="hl opt">(</span><span class="hl str">&apos; aaa, bb, aa,</span><span class="hl esc">\n\t</span><span class="hl str">bb, aaa, Aaa&apos;</span><span class="hl opt">)</span>
    <span class="hl opt">{</span> Aaa<span class="hl opt">:</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&apos;aa,&apos;</span><span class="hl opt">:</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&apos;aaa,&apos;</span><span class="hl opt">:</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl str">&apos;bb,&apos;</span><span class="hl opt">:</span> <span class="hl num">2</span> <span class="hl opt">}</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">wordCounts</span><span class="hl opt">(</span><span class="hl str">&apos;x&apos;</span><span class="hl opt">)</span>
    <span class="hl opt">{</span> x<span class="hl opt">:</span> <span class="hl num">1</span> <span class="hl opt">}</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">wordCounts</span><span class="hl opt">(</span><span class="hl str">&apos;&apos;</span><span class="hl opt">)</span>
    <span class="hl opt">{}</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">wordCounts</span><span class="hl opt">(</span><span class="hl str">&apos;  &apos;</span><span class="hl opt">)</span>
    <span class="hl opt">{}</span>
    <span class="hl opt">&gt;</span></pre><p data-coord="hw1-sol.umt:509:4">Compute runs of sorted words and then use the runs to compute
the word-count object.
</p><pre>    function <span class="hl kwd">wordCounts</span><span class="hl opt">(</span>text<span class="hl opt">) {</span>
      <span class="hl kwb">const</span> sorted <span class="hl opt">=</span> <span class="hl kwd">words</span><span class="hl opt">(</span>text<span class="hl opt">).</span><span class="hl kwd">sort</span><span class="hl opt">();</span>
      <span class="hl kwb">const</span> wordRuns <span class="hl opt">=</span> sorted<span class="hl opt">.</span>length <span class="hl opt">&gt;</span> <span class="hl num">0</span> <span class="hl opt">?</span> <span class="hl kwd">runs</span><span class="hl opt">(</span>sorted<span class="hl opt">) : [];</span>
      <span class="hl kwa">return</span> Object<span class="hl opt">.</span><span class="hl kwd">fromEntries</span><span class="hl opt">(</span>
        wordRuns<span class="hl opt">.</span><span class="hl kwd">map</span><span class="hl opt">(</span>run <span class="hl opt">=&gt; [</span>run<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">],</span> run<span class="hl opt">.</span>length<span class="hl opt">])</span>
      <span class="hl opt">);</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:522:0"><p data-coord="hw1-sol.umt:522:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:522:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:522:81">modeWord(text)</samp> which returns the word which occurs most
often in <samp data-coord="hw1-sol.umt:522:152">text</samp> (which is guaranteed to contain at least one
word).  If multiple distinct words occur most often, then the
returned word should be the lexicographical smaller word.
<em data-coord="hw1-sol.umt:522:336">5-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">modeWord</span><span class="hl opt">(</span><span class="hl str">&apos; aaa bb aa</span><span class="hl esc">\n\t</span><span class="hl str">bb aaa Aaa&apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;aaa&apos;</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">modeWord</span><span class="hl opt">(</span><span class="hl str">&apos; aaa bb aa</span><span class="hl esc">\n\t</span><span class="hl str">bb aaa Aaa bb&apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;bb&apos;</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">modeWord</span><span class="hl opt">(</span><span class="hl str">&apos; x &apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;x&apos;</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">modeWord</span><span class="hl opt">(</span><span class="hl str">&apos;x&apos;</span><span class="hl opt">)</span>
    <span class="hl str">&apos;x&apos;</span>
    <span class="hl opt">&gt;</span></pre><p data-coord="hw1-sol.umt:541:4">Pick up word with maximum word-count.
</p><pre>    function <span class="hl kwd">modeWord</span><span class="hl opt">(</span>text<span class="hl opt">) {</span>
      <span class="hl kwa">return</span> Object<span class="hl opt">.</span><span class="hl kwd">entries</span><span class="hl opt">(</span><span class="hl kwd">wordCounts</span><span class="hl opt">(</span>text<span class="hl opt">)).</span>
        <span class="hl kwd">sort</span><span class="hl opt">((</span>a<span class="hl opt">,</span> b<span class="hl opt">) =&gt;</span> a<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] !==</span> b<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] ?</span> b<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] -</span> a<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]</span>
                                     <span class="hl opt">: (</span>a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] &lt;</span> b<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] ? -</span><span class="hl num">1</span> <span class="hl opt">: +</span><span class="hl num">1</span><span class="hl opt">))</span>
        <span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">][</span><span class="hl num">0</span><span class="hl opt">];</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:552:0"><p data-coord="hw1-sol.umt:552:4">Subject to the above <a href="#restrict" data-coord="hw1-sol.umt:552:38">restrictions,</a> show code for a
function <samp data-coord="hw1-sol.umt:552:81">primes(n)</samp> which returns all the prime numbers less
than or equal to positive integer <samp data-coord="hw1-sol.umt:552:172">n</samp>. <em data-coord="hw1-sol.umt:552:177">6-points</em>
</p><pre>    <span class="hl opt">&gt;</span> <span class="hl kwd">primes</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">)</span>
    <span class="hl opt">[</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">,</span> <span class="hl num">7</span> <span class="hl opt">]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">primes</span><span class="hl opt">(</span><span class="hl num">11</span><span class="hl opt">)</span>
    <span class="hl opt">[</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">11</span> <span class="hl opt">]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">primes</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">)</span>
    <span class="hl opt">[</span>
       <span class="hl num">2</span><span class="hl opt">,</span>  <span class="hl num">3</span><span class="hl opt">,</span>  <span class="hl num">5</span><span class="hl opt">,</span>  <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">13</span><span class="hl opt">,</span> <span class="hl num">17</span><span class="hl opt">,</span> <span class="hl num">19</span><span class="hl opt">,</span>
       <span class="hl num">23</span><span class="hl opt">,</span> <span class="hl num">29</span><span class="hl opt">,</span> <span class="hl num">31</span><span class="hl opt">,</span> <span class="hl num">37</span><span class="hl opt">,</span> <span class="hl num">41</span><span class="hl opt">,</span> <span class="hl num">43</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">,</span> <span class="hl num">53</span><span class="hl opt">,</span>
       <span class="hl num">59</span><span class="hl opt">,</span> <span class="hl num">61</span><span class="hl opt">,</span> <span class="hl num">67</span><span class="hl opt">,</span> <span class="hl num">71</span><span class="hl opt">,</span> <span class="hl num">73</span><span class="hl opt">,</span> <span class="hl num">79</span><span class="hl opt">,</span> <span class="hl num">83</span><span class="hl opt">,</span> <span class="hl num">89</span><span class="hl opt">,</span>
       <span class="hl num">97</span>
    <span class="hl opt">]</span>
    <span class="hl opt">&gt;</span> <span class="hl kwd">primes</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">)</span>
    <span class="hl opt">[]</span>
    <span class="hl opt">&gt;</span> </pre><p data-coord="hw1-sol.umt:573:4">Candidates for primes are from \(2\ldots n\).  Initializing primes
to the first candidate, for each remaining candidate add it to
primes if it is not a multiple of a previously computed prime.
</p><pre>    function <span class="hl kwd">primes</span><span class="hl opt">(</span>n<span class="hl opt">) {</span>
      <span class="hl kwa">if</span> <span class="hl opt">(</span>n <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">) {</span>
        <span class="hl kwa">return</span> <span class="hl opt">[];</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">else</span> <span class="hl opt">{</span>
        <span class="hl kwb">const</span> candidates <span class="hl opt">=</span> Array<span class="hl opt">.</span><span class="hl kwd">from</span><span class="hl opt">({</span>length<span class="hl opt">:</span> n <span class="hl opt">-</span> <span class="hl num">2</span> <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">}).</span>
          <span class="hl kwd">map</span><span class="hl opt">((</span>_<span class="hl opt">,</span> i<span class="hl opt">) =&gt;</span> i <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">);</span>
        <span class="hl kwa">return</span> candidates<span class="hl opt">.</span>
          <span class="hl kwd">reduce</span><span class="hl opt">((</span>acc<span class="hl opt">,</span> i<span class="hl opt">) =&gt;</span>
                    acc<span class="hl opt">.</span><span class="hl kwd">some</span><span class="hl opt">(</span>d <span class="hl opt">=&gt;</span> i<span class="hl opt">%</span>d <span class="hl opt">===</span> <span class="hl num">0</span><span class="hl opt">)</span>
                    <span class="hl opt">?</span> acc
                    <span class="hl opt">:</span> acc<span class="hl opt">.</span><span class="hl kwd">concat</span><span class="hl opt">([</span>i<span class="hl opt">]),</span>
                 <span class="hl opt">[</span>candidates<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]]);</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span></pre></li><li data-coord="hw1-sol.umt:595:0"><p data-coord="hw1-sol.umt:595:4">Given a vocabulary \(\Sigma\) containing 2 symbols <samp data-coord="hw1-sol.umt:595:54">a</samp> and <samp data-coord="hw1-sol.umt:595:62">b</samp>,
give regex's for the following: <em data-coord="hw1-sol.umt:595:103">10-points</em>
</p><ol data-coord="hw1-sol.umt:598:0"><li data-coord="hw1-sol.umt:598:0"><p data-coord="hw1-sol.umt:598:8">All strings over \(\Sigma\) which start with <samp data-coord="hw1-sol.umt:598:52">b</samp> and end with <samp data-coord="hw1-sol.umt:598:69">a</samp>.
</p></li><li data-coord="hw1-sol.umt:600:0"><p data-coord="hw1-sol.umt:600:8">All strings over \(\Sigma\) which have length less than 10 and
end with <samp data-coord="hw1-sol.umt:600:87">a</samp>.
</p></li><li data-coord="hw1-sol.umt:603:0"><p data-coord="hw1-sol.umt:603:8">All strings over \(\Sigma\) whose length is divisible by 10.
</p></li><li data-coord="hw1-sol.umt:605:0"><p data-coord="hw1-sol.umt:605:8">All strings over \(\Sigma\) which contain more <samp data-coord="hw1-sol.umt:605:54">b</samp>'s than <samp data-coord="hw1-sol.umt:605:65">a</samp>'s.
</p></li><li data-coord="hw1-sol.umt:607:0"><p data-coord="hw1-sol.umt:607:8">All strings over \(\Sigma\) which contain 10 or more <samp data-coord="hw1-sol.umt:607:60">a</samp>'s.
</p></li></ol><p data-coord="hw1-sol.umt:609:4">The answers follow:
</p><ol data-coord="hw1-sol.umt:611:0"><li data-coord="hw1-sol.umt:611:0"><p data-coord="hw1-sol.umt:611:8"><samp data-coord="hw1-sol.umt:611:8">b(a|b)*a</samp>.  String consists of a <samp data-coord="hw1-sol.umt:611:42">b</samp> follows by any possibly
empty string over \(\Sigma\), followed by a single <samp data-coord="hw1-sol.umt:611:128">a</samp>.
</p></li><li data-coord="hw1-sol.umt:614:0"><p data-coord="hw1-sol.umt:614:8"><samp data-coord="hw1-sol.umt:614:8">(a|b){0,8}a</samp>.  String consists of any possibly empty string
over \(\Sigma\) containing up to 8 characters followed by a
single <samp data-coord="hw1-sol.umt:614:144">a</samp>.
</p></li><li data-coord="hw1-sol.umt:618:0"><p data-coord="hw1-sol.umt:618:8"><samp data-coord="hw1-sol.umt:618:8">((a|b){10})*</samp>.  Zero-or-more repetitions of strings over
\(\Sigma\) having length 10.
</p></li><li data-coord="hw1-sol.umt:621:0"><p data-coord="hw1-sol.umt:621:8">Cannot be done since regex's cannot count.
</p></li><li data-coord="hw1-sol.umt:623:0"><p data-coord="hw1-sol.umt:623:8"><samp data-coord="hw1-sol.umt:623:8">(b*ab*){10,}</samp>. 10-or-more <samp data-coord="hw1-sol.umt:623:35">a</samp>'s with each <samp data-coord="hw1-sol.umt:623:51">a</samp>
possibly preceeded / followed by 0-or-more <samp data-coord="hw1-sol.umt:623:106">b</samp>'s.
</p></li></ol></li><li data-coord="hw1-sol.umt:627:0"><p data-coord="hw1-sol.umt:627:4">Traditionally, JavaScript used objects to implement the
functionality of a
<a href="https://en.wikipedia.org/wiki/Associative_array" data-coord="hw1-sol.umt:627:138">dictionary</a>
which maintains a mapping between keys and values.  Recently,
JavaScript added the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" data-coord="hw1-sol.umt:627:336">Map</a> datatype.
</p><p data-coord="hw1-sol.umt:635:5">Compare the use of JavaScript objects and <samp data-coord="hw1-sol.umt:635:47">Map</samp>'s to implement
dictionaries. <em data-coord="hw1-sol.umt:635:87">15-points</em>
</p><p data-coord="hw1-sol.umt:638:5">Oops, I did not realize that MDN has added the comparison
directly in their
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" data-coord="hw1-sol.umt:638:184">Map</a> reference.  Anyway, the answer I had in mind is along
the lines of the comparison provided by MDN:
</p><ul data-coord="hw1-sol.umt:644:0"><li data-coord="hw1-sol.umt:644:0"><p data-coord="hw1-sol.umt:644:8">Object keys are restricted to <samp data-coord="hw1-sol.umt:644:38">String</samp>'s (also <samp data-coord="hw1-sol.umt:644:55">Symbol</samp>'s which
we have not yet covered).  The keys to a <samp data-coord="hw1-sol.umt:644:121">Map</samp> can be any JavaScript
value.
</p></li><li data-coord="hw1-sol.umt:648:0"><p data-coord="hw1-sol.umt:648:8">Objects come with a prototype which may have other keys.  With
maps the only keys are those which are added.
</p></li><li data-coord="hw1-sol.umt:651:0"><p data-coord="hw1-sol.umt:651:8">Since ES6, objects preserve insertion order among <samp data-coord="hw1-sol.umt:651:58">String</samp> keys.
Maps preserve insertion order among <strong data-coord="hw1-sol.umt:651:117">all</strong> keys.
</p><pre>        <span class="hl opt">&gt;</span> x <span class="hl opt">= {}</span>
        <span class="hl opt">{}</span>
        <span class="hl opt">&gt;</span> x<span class="hl opt">.</span>a <span class="hl opt">=</span> <span class="hl num">22</span>
        <span class="hl num">22</span>
        <span class="hl opt">&gt;</span> x<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> <span class="hl num">33</span>
        <span class="hl num">33</span>
        <span class="hl opt">&gt;</span> x
        <span class="hl opt">{</span> <span class="hl str">&apos;1&apos;</span><span class="hl opt">:</span> <span class="hl num">33</span><span class="hl opt">,</span> a<span class="hl opt">:</span> <span class="hl num">22</span> <span class="hl opt">}</span>
        <span class="hl opt">&gt;</span> y <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Map</span><span class="hl opt">()</span>
        <span class="hl kwd">Map</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
        <span class="hl opt">&gt;</span> y<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl str">&apos;a&apos;</span><span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">)</span>
        <span class="hl kwd">Map</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">) {</span> <span class="hl str">&apos;a&apos;</span> <span class="hl opt">=&gt;</span> <span class="hl num">22</span> <span class="hl opt">}</span>
        <span class="hl opt">&gt;</span> y<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl str">&apos;1&apos;</span><span class="hl opt">,</span> <span class="hl num">33</span><span class="hl opt">)</span>
        <span class="hl kwd">Map</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) {</span> <span class="hl str">&apos;a&apos;</span> <span class="hl opt">=&gt;</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl str">&apos;1&apos;</span> <span class="hl opt">=&gt;</span> <span class="hl num">33</span> <span class="hl opt">}</span>
        <span class="hl opt">&gt;</span></pre></li><li data-coord="hw1-sol.umt:672:0"><p data-coord="hw1-sol.umt:672:8">It is possible to iterate over a <samp data-coord="hw1-sol.umt:672:41">Map</samp> directly.  Given the
above <samp data-coord="hw1-sol.umt:672:82">x</samp> and <samp data-coord="hw1-sol.umt:672:90">y</samp>:
</p><pre>        <span class="hl opt">&gt;</span> <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">const</span> x of y<span class="hl opt">)</span> console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span>x<span class="hl opt">);</span>  
        <span class="hl opt">[</span> <span class="hl str">&apos;a&apos;</span><span class="hl opt">,</span> <span class="hl num">22</span> <span class="hl opt">]</span>
        <span class="hl opt">[</span> <span class="hl str">&apos;1&apos;</span><span class="hl opt">,</span> <span class="hl num">33</span> <span class="hl opt">]</span>
        undefined
        <span class="hl opt">&gt;</span></pre><p data-coord="hw1-sol.umt:683:1">Iterating over an object needs to be done manually.  Something like:
</p><pre>        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">const</span> pair of Object<span class="hl opt">.</span><span class="hl kwd">entries</span><span class="hl opt">(</span>x<span class="hl opt">))</span> console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span>pair<span class="hl opt">);</span>
        <span class="hl opt">[</span> <span class="hl str">&apos;1&apos;</span><span class="hl opt">,</span> <span class="hl num">33</span> <span class="hl opt">]</span>
        <span class="hl opt">[</span> <span class="hl str">&apos;a&apos;</span><span class="hl opt">,</span> <span class="hl num">22</span> <span class="hl opt">]</span>
        undefined
        <span class="hl opt">&gt;</span>       </pre><p data-coord="hw1-sol.umt:693:8">which is actually iterating over an array.
</p></li><li data-coord="hw1-sol.umt:695:0"><p data-coord="hw1-sol.umt:695:8">Obtaining the number of elements of a <samp data-coord="hw1-sol.umt:695:46">Map</samp> can be done easily
using its <samp data-coord="hw1-sol.umt:695:89">size()</samp> method.  For an object, it must be done
manually often by building up an array (using the <samp data-coord="hw1-sol.umt:695:196">keys()</samp>,
<samp data-coord="hw1-sol.umt:695:214">entries()</samp> or <samp data-coord="hw1-sol.umt:695:229">values()</samp> methods from <samp data-coord="hw1-sol.umt:695:253">Object</samp>) and getting
its <samp data-coord="hw1-sol.umt:695:287">length</samp>.
</p></li><li data-coord="hw1-sol.umt:701:0"><p data-coord="hw1-sol.umt:701:8">It is likely that <samp data-coord="hw1-sol.umt:701:26">Map</samp>'s are implemented more efficiently
than objects.
</p></li></ul></li><li data-coord="hw1-sol.umt:704:0"><p data-coord="hw1-sol.umt:704:4">Discuss the validity of the following statements.  What is more
important than whether you ultimately classify the statement as
<strong data-coord="hw1-sol.umt:704:140">true</strong> or <strong data-coord="hw1-sol.umt:704:150">false</strong> is your justification for arriving at your
conclusion. <em data-coord="hw1-sol.umt:704:217">15-points</em>
</p><ol data-coord="hw1-sol.umt:709:0"><li data-coord="hw1-sol.umt:709:0"><p data-coord="hw1-sol.umt:709:8">The binary relation <samp data-coord="hw1-sol.umt:709:28">&lt;</samp> is
<a href="https://en.wikipedia.org/wiki/Trichotomy_(mathematics)" data-coord="hw1-sol.umt:709:109">trichotomous</a> on JavaScript numbers.
</p></li><li data-coord="hw1-sol.umt:713:0"><p data-coord="hw1-sol.umt:713:8">Given a JavaScript declaration <code><span class="hl kwb">const</span> x <span class="hl opt">= {};</span></code>, then
the assignment <code>x<span class="hl opt">.</span>a <span class="hl opt">=</span> <span class="hl num">22</span><span class="hl opt">;</span></code> is illegal as it modifies
<samp data-coord="hw1-sol.umt:713:132">x</samp>.
</p></li><li data-coord="hw1-sol.umt:717:0"><p data-coord="hw1-sol.umt:717:8">If <samp data-coord="hw1-sol.umt:717:11">s</samp> is a non-empty string, then the assignment <code>s<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl str">&apos;a&apos;</span><span class="hl opt">;</span></code>
will cause an error since JavaScript strings are immutable.
</p></li><li data-coord="hw1-sol.umt:720:0"><p data-coord="hw1-sol.umt:720:8">It is possible to write a JavaScript string literal
so that it spans multiple lines.
</p></li><li data-coord="hw1-sol.umt:723:0"><p data-coord="hw1-sol.umt:723:8">If <samp data-coord="hw1-sol.umt:723:11">string.match(regex)</samp> succeeds with value <samp data-coord="hw1-sol.umt:723:53">m</samp>, then
<samp data-coord="hw1-sol.umt:723:71">m.length === n + 1</samp> where <samp data-coord="hw1-sol.umt:723:98">n</samp> is the number of parentheses
pairs in <samp data-coord="hw1-sol.umt:723:148">regex</samp>.
</p></li></ol><p data-coord="hw1-sol.umt:727:4">The answers follow:
</p><ol data-coord="hw1-sol.umt:729:0"><li data-coord="hw1-sol.umt:729:0"><p data-coord="hw1-sol.umt:729:8">JavaScript numbers are not trichotomous because of the
presence of <samp data-coord="hw1-sol.umt:729:83">NaN</samp>.  It will be the case that all of
\(a < b\), \(a = b\) and \(a > b\) are <strong data-coord="hw1-sol.umt:729:167">false</strong> if either
\(a\) or \(b\) are <samp data-coord="hw1-sol.umt:729:210">NaN</samp>.  Hence the statement is <strong data-coord="hw1-sol.umt:729:241">false</strong>.
</p></li><li data-coord="hw1-sol.umt:734:0"><p data-coord="hw1-sol.umt:734:8">The declaration declares <samp data-coord="hw1-sol.umt:734:33">x</samp> as a constant reference to an
object; i.e. the object itself is not declared constant.
Assigning directly to <samp data-coord="hw1-sol.umt:734:162">x</samp> is illegal, but assigning to the
properties of the object referenced by <samp data-coord="hw1-sol.umt:734:246">x</samp> is permissible and
the statement is <strong data-coord="hw1-sol.umt:734:294">false</strong>.
</p><p data-coord="hw1-sol.umt:740:8">[It is possible to make the properties of <samp data-coord="hw1-sol.umt:740:50">x</samp> immutable using
<samp data-coord="hw1-sol.umt:740:78">Object.freeze(x)</samp>.]
</p></li><li data-coord="hw1-sol.umt:743:0"><p data-coord="hw1-sol.umt:743:8">Strings are indeed immutable and the assignment will fail, but
silently without any error.  Hence the statement is <strong data-coord="hw1-sol.umt:743:131">false</strong>.
</p></li><li data-coord="hw1-sol.umt:746:0"><p data-coord="hw1-sol.umt:746:8">Template string literals delimited using backquotes <samp data-coord="hw1-sol.umt:746:60">`</samp> can
span multiple lines.  Hence the statement is <strong data-coord="hw1-sol.umt:746:122">true</strong>.
</p></li><li data-coord="hw1-sol.umt:749:0"><p data-coord="hw1-sol.umt:749:8">If <samp data-coord="hw1-sol.umt:749:11">string.match(regex) === a</samp>, then <samp data-coord="hw1-sol.umt:749:45">a.length === n + 1</samp>
where <samp data-coord="hw1-sol.umt:749:80">n</samp> is the number of <strong data-coord="hw1-sol.umt:749:101">capturing</strong> parentheses pairs in
<samp data-coord="hw1-sol.umt:749:142">regex</samp>.  Since some of the parentheses pairs in <samp data-coord="hw1-sol.umt:749:191">regex</samp> may
not be capturing, the statement is <strong data-coord="hw1-sol.umt:749:246">false</strong>.
</p></li></ol></li></ol></section>
    </div> <!-- #content -->
    <script src="../../assets/scripts/loginAction.js"></script>
  </body>
</html>
