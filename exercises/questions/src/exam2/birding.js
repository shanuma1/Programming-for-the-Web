'use strict';

const assert = require('assert');

const TIMESTAMP = 'Time-stamp: <2020-04-29 01:36:18 umrigar>';

const {Question, Rand, emacsTimestampToMillis} = require('gen-q-and-a');

class Birding extends Question {

  constructor(params) {
    super(params);
    this.addParamSpec(PARAMS);
    this.addQuestion(QUESTION);
    this.freeze();
    this.addAnswer(ANSWER);
    this.makeContent();
  }

}

module.exports = Birding
Object.assign(Birding, {
  id: 'birding',
  title: 'Birding Web Service and Persistence Interface',
  timestamp: emacsTimestampToMillis(TIMESTAMP),
  version: '1.0.0',
});

const QUESTION = `
Part (a) of this question requires you to design web services, while
Part (b) requires you to design an interface to support those web
services.

  # Design RESTful web services for a birder web site.  Supported
    entity types would include:

      + A *birder* has the usual attributes associated with persons like 
        "name", "email", etc. 

      + A *bird* is characterized by attributes like "species",
        "common-name", a list of taxonomic terms classifying the bird,
        a textual description (indexed by keywords like size and
        color).

        For example, the bird having "common-name" \`American crow\`
        belongs to the species \`corvus brachyrhynchos\` with
        higher-level taxonomic terms like \`passerine\` and
        \`corvidae\`.  It's description would be chacterized by
        keywords like \`medium-size\` and \`black\`.

      + A sighting is characterized by a date-time and geo-location
        like latitude and longitude.

    Your web services should allow searching for, creating, updating
    and deleting each of the above types of entities.  Your answer
    should include:

      + A discussion of the ID used for an entity; whether it is generated
        external to the web service or internal to the web service.

      + The URLs you would use for each services.

      + The HTTP methods used for each service.

      + Support for HATEOAS.  "23-points"  

    Your answer should resemble the requirements for *Project 3*.
    "23-points"

  # Design an *interface* for a persistence store to support the
    birding web services from the previous question.  Your answer
    should include:

      + A specification for the interface.

      + A discussion of error situations.

    Your answer should resemble the requirements for *Project 2*.
    "22-points"

`;

const ANSWER = `
  It seems reasonable to use an external "email" for the ID for a
  person, but this has a couple of problems:

    + Multiple people (like couples) may share the same "email".

    + A person's "email" may change.

  For these reasons, an "email" can be used as a human-visible
  identifier for identifying a person.  Internally however,
  an internally generated id would be used.  This internal
  ID would be used in all URLs generated by the web service.
  This would make it possible to easily change the "email"
  associated with a person without breaking links.

  For birds, the external "species" seems a candidate for an ID.
  However, taxonomies are fluid and subject to change, expecially with
  advances in DNA analysis.  So using an internal ID would probably be
  more future proof.

  Sightings do not have candidates for an external ID and a internally
  generated ID would be the only possibility.

  The above discussions shows that since our applications cannot
  control the external world, it is a bad idea to depend on external
  identifiers as ID's.  So usually we do not want to use external
  identifiers as ID's unless it is explicitly marketed as such (like
  a SSN), and sometimes not even then.

  The URLs and methods for birders could be something like:

    + \`/birders\`: A \`GET\` to this url would be used for listing
      birders; query parameters like "email", "name", etc.  A \`POST\`
      to this URL would allow creating a birder with the \`Location\`
      header in the response specifying the URL of the newly created
      birder.

    + \`/birders/\` .= "id": A \`GET\` would return all the
      information associated with the birder indentifed by "id".  A
      \`DELETE\` would delete the birder if there are no sightings
      associated with that birder; a \`PATCH\` would be used for
      update.

  Similar URLs (like \`/birds\`) and HTTP methods could be used for
  birds.

  Unlike birders and birds, a sighting is dependent on both birders
  and birds (the dependencies are not completely the same as the
  birder actively initiates the sighting, whereas the bird passively
  participates in the sighting).

  We could have the following URLs:

     + \`/sightings\` and \`/sightings/\` .- "id": HTTP methods
       similar to birder/bird.

     + \`/birders/\` .- "birderId" .- \`sightings\` and \`/birders/\`
       .- "birderId" .- \`/sightings/\` .- "id": Sightings made by
       "birderId".  HTTP methods as before.

     + \`/birds/\` .- "birdId" .- \`sightings\` and \`/birds/\` .-
       "birdId" .- \`/sightings/\` .- "id": Sightings for "birdId".
       HTTP methods as before.

  Note that the "id" for a particular sighting would be the same for
  all URLs.  A case can be made for all of the above URLs:

     + The first URL would allow looking for a sighting by attributes
       independent of birder or bird, like location, date range, etc.

     + The second URL would automatically be restricted to sightings
       by a particular birder.

     + The third URL would automatically be restricted to sightings
       of a particular bird.

  For HATEOAS, we could support the a URL like \`/\` which returns the
  links containing the URLs for birders, birds and sightings.  The
  birder and bird results for a particular birder/bird could contain
  links to the URL for sightings for that birder/bird.  Each sighting
  result could contain links to the birder making the sighting and the
  bird sighted.  All search results could contain scrolling links for
  \`rel="next"\` and \`rel="prev"\`.

  The implementation would provide the following interface:

  ~~~
  /** create an object of specified category (birders, birds, sightings)
   *  with parameters specified by createSpecs.  Return internal id of newly
   *  created object.
   */
  create(category, createSpecs);

  /** return objects for specified category (birders, birds, sightings)
   *  filtered by findSpecs
   */
  find(category, findSpecs={});

  /** Remove up to one object belonging to category (birders, birds, 
   *  sightings) specified by rmSpecs.id.
   */
  remove(category, rmSpecs) {

  /** Remove one object belonging to category (birders, birds, 
   *  sightings) specified by updateSpecs.id.
   */
  update(category, updateSpecs) {
  ~~~

  The following error situations should be handled:

    + It would be an error to create a birder or bird having the
      same external id like email as an existing object.

    + It would be an error to remove a birder or bird if there are any
      sightings involving that birder or bird.  

    + It would be an error to create/update a sighting with invalid
      ids for the associated birder or bird.
`;

const PARAMS = [
];

if (process.argv[1] === __filename) {
  console.log(new Birding().qaText());
}
