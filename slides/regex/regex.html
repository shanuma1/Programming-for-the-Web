<!doctype html>
<html lang='en-US'>
<head>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" />
  <title>CS 544: Regular Expressions</title>
<link href="regex/hl-fine_blue.css" rel="stylesheet"/><link href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" 
       rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script>    

</head>
<body>
    <nav>
      <ul>
	<li><a href="../../index.html" class="material-icons">house</a></li>
	<li><a href="../../docs/index.html">Docs</a></li>
	<li><a href="../../exams-quizzes/index.html">Exams &amp; Quizzes</a></li>
	<li><a href="../../exercises/index.html">Exercises</a></li>
	<li><a href="../../hws/index.html">Homeworks</a></li>
	<li><a href="../../misc/index.html">Misc</a></li>
	<li><a href="../../projects/index.html">Projects</a></li>
	<li><a href="../../slides/index.html">Slides</a></li>
	<li><a id="loginAction"></a></li>
      </ul>
    </nav>
  <div class="slide-controls" style="display: none;">
    <span class="float-left">
      <span class="first-control">
	<a href="#">
	  <img src="../../assets/images/go-first.png">
	</a>
      </span>
      <span class="previous-control">
	<a href="#">
	  <img src="../../assets/images/go-previous.png">
	</a>
      </span>
    </span>
    <span class="float-right">
      <span class="next-control">
	<a href="#">
	  <img src="../../assets/images/go-next.png">
	</a>
      </span>
      <span class="last-control">
	<a href="#">
	  <img src="../../assets/images/go-last.png">
	</a>
      </span>
    </span>
    <div class="slide-end">&nbsp;<br></div> <!-- hack -->
  </div>
<div class="content">
<section data-coord="regex.umt:1:0"><h1 data-coord="regex.umt:1:0">Regular Expressions</h1><section class="umt-slide" data-coord="regex.umt:4:0"><h2 data-coord="regex.umt:4:0">Overview</h2><ul data-coord="regex.umt:8:0"><li data-coord="regex.umt:8:0"><p data-coord="regex.umt:8:4">Basic regex's.
</p></li><li data-coord="regex.umt:10:0"><p data-coord="regex.umt:10:4"><samp data-coord="regex.umt:10:4">String</samp> methods.
</p></li><li data-coord="regex.umt:12:0"><p data-coord="regex.umt:12:4"><samp data-coord="regex.umt:12:4">RegExp</samp> methods.
</p></li><li data-coord="regex.umt:14:0"><p data-coord="regex.umt:14:4">Word count <samp data-coord="regex.umt:14:15">wc</samp> example.
</p></li></ul></section><section class="umt-slide" data-coord="regex.umt:17:0"><h2 data-coord="regex.umt:17:0">Regular Expressions Introduction</h2><ul data-coord="regex.umt:21:0"><li data-coord="regex.umt:21:0"><p data-coord="regex.umt:21:4">Regex's provide special syntax for string matching.
</p></li><li data-coord="regex.umt:23:0"><p data-coord="regex.umt:23:4">Allows matching, sub-string extraction and substitution.
</p></li><li data-coord="regex.umt:25:0"><p data-coord="regex.umt:25:4">Initially popularized by early Unix tools.
</p></li><li data-coord="regex.umt:27:0"><p data-coord="regex.umt:27:4">Indispensable tool in every programmer's toolbox.
</p></li></ul></section><section class="umt-slide" data-coord="regex.umt:30:0"><h2 data-coord="regex.umt:30:0">Basic Regex Syntax</h2><p data-coord="regex.umt:33:0">A regular expression literal can be written within <samp data-coord="regex.umt:33:51">/</samp> delimiters.
</p><dl data-coord="regex.umt:36:0"><dt data-coord="regex.umt:36:2"> <samp data-coord="regex.umt:36:1">/hello/</samp> </dt><dd data-coord="regex.umt:37:0"><p data-coord="regex.umt:37:4">Matches the string <samp data-coord="regex.umt:37:23">"hello"</samp>.
</p></dd><dt data-coord="regex.umt:39:2"> <samp data-coord="regex.umt:39:1">/hello|world/</samp> </dt><dd data-coord="regex.umt:40:0"><p data-coord="regex.umt:40:4">Matches either the string <samp data-coord="regex.umt:40:30">"hello"</samp> or the string <samp data-coord="regex.umt:40:54">"world"</samp>.
<samp data-coord="regex.umt:40:69">|</samp> is the <strong data-coord="regex.umt:40:80">alternation operator</strong>.
</p></dd><dt data-coord="regex.umt:43:2"> <samp data-coord="regex.umt:43:1">/[hH]ello/</samp> </dt><dd data-coord="regex.umt:44:0"><p data-coord="regex.umt:44:4">Matches either the string <samp data-coord="regex.umt:44:30">"hello"</samp> or the string <samp data-coord="regex.umt:44:54">"Hello"</samp>.
<samp data-coord="regex.umt:44:69">[hH]</samp> is a character class equivalent to <samp data-coord="regex.umt:44:111">/(h|H)/</samp>.
</p></dd><dt data-coord="regex.umt:47:2"> <samp data-coord="regex.umt:47:1">/[0-9]/</samp> </dt><dd data-coord="regex.umt:48:0"><p data-coord="regex.umt:48:4">Matches a digit.  <samp data-coord="regex.umt:48:22">[0-9]</samp> is a <strong data-coord="regex.umt:48:35">range character class</strong>.
</p></dd><dt data-coord="regex.umt:50:2"> <samp data-coord="regex.umt:50:1">/[^0-9]/</samp> </dt><dd data-coord="regex.umt:51:0"><p data-coord="regex.umt:51:3">Matches a non-digit. <samp data-coord="regex.umt:51:24">[^0-9]</samp> is a <strong data-coord="regex.umt:51:38">negated character class</strong>.
</p></dd><dt data-coord="regex.umt:54:2"> <samp data-coord="regex.umt:54:1">/worlds?/</samp> </dt><dd data-coord="regex.umt:55:0"><p data-coord="regex.umt:55:4">Matches either the string <samp data-coord="regex.umt:55:30">"worlds"</samp> or the string <samp data-coord="regex.umt:55:55">"world"</samp>.
<samp data-coord="regex.umt:55:70">?</samp> is a suffix operator indicating that the preceeding
sub-regex is <strong data-coord="regex.umt:55:143">optional</strong>.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:60:0"><h2 data-coord="regex.umt:60:0">Basic Regex Syntax: Continued</h2><dl data-coord="regex.umt:63:0"><dt data-coord="regex.umt:63:2"> /[0-9]+/ </dt><dd data-coord="regex.umt:64:0"><p data-coord="regex.umt:64:4">Matches one-or-more digits.  <samp data-coord="regex.umt:64:33">+</samp> is a suffix operator indicating
<strong data-coord="regex.umt:64:73">one-or-more</strong> matches of the preceeding regex.
</p></dd><dt data-coord="regex.umt:67:2"> /[a-zA-Z]*/ </dt><dd data-coord="regex.umt:68:0"><p data-coord="regex.umt:68:4">Matches zero-or-more lowercase or uppercase alphabetic characters.
<samp data-coord="regex.umt:68:75">*</samp> is a suffix operator indicating <strong data-coord="regex.umt:68:111">zero-or-more</strong> matches of the
preceeding regex.
</p></dd></dl><ul data-coord="regex.umt:73:0"><li data-coord="regex.umt:73:0"><p data-coord="regex.umt:73:4">So the basic regular expression operators in order of decreasing
precedence are:
</p><dl data-coord="regex.umt:76:0"><dt data-coord="regex.umt:76:5"> Quantifiers optional <samp data-coord="regex.umt:76:22">?</samp>, one-or-more <samp data-coord="regex.umt:76:39">+</samp>, zero-or-more <samp data-coord="regex.umt:76:57">*</samp></dt><dd data-coord="regex.umt:77:0"><p data-coord="regex.umt:77:7">Indicated by unary suffix operators.
</p></dd><dt data-coord="regex.umt:79:5">Concatenation</dt><dd data-coord="regex.umt:80:0"><p data-coord="regex.umt:80:7">Indicated by juxtaposition.
</p></dd><dt data-coord="regex.umt:82:5">Alternation</dt><dd data-coord="regex.umt:83:0"><p data-coord="regex.umt:83:7">Indicated by infix binary operator <samp data-coord="regex.umt:83:42">|</samp>.
</p></dd></dl></li><li data-coord="regex.umt:85:0"><p data-coord="regex.umt:85:4">Use parentheses <samp data-coord="regex.umt:85:20">(</samp> <samp data-coord="regex.umt:85:24">)</samp> to override default precedence.
</p></li></ul></section><section class="umt-slide" data-coord="regex.umt:88:0"><h2 data-coord="regex.umt:88:0">Escaping Special Characters</h2><ul data-coord="regex.umt:91:0"><li data-coord="regex.umt:91:0"><p data-coord="regex.umt:91:4">Characters like <samp data-coord="regex.umt:91:20">+</samp>, <samp data-coord="regex.umt:91:25">*</samp> <samp data-coord="regex.umt:91:29">|</samp>, <samp data-coord="regex.umt:91:34">?</samp>, <samp data-coord="regex.umt:91:39">(</samp>, <samp data-coord="regex.umt:91:44">)</samp> are part of the
regular expression notation and are referred to as
special characters or <strong data-coord="regex.umt:91:145">meta-characters</strong>.
</p></li><li data-coord="regex.umt:95:0"><p data-coord="regex.umt:95:4">Special characters can be escaped by preceeding them with a <samp data-coord="regex.umt:95:64">\</samp>
character.  For example, <samp data-coord="regex.umt:95:97">/hello\*/</samp> is a regex matching the
string <samp data-coord="regex.umt:95:144">"hello*"</samp>.
</p></li><li data-coord="regex.umt:99:0"><p data-coord="regex.umt:99:4">The <samp data-coord="regex.umt:99:8">\</samp> character can itself be escaped using a preceeding <samp data-coord="regex.umt:99:63">\</samp>.
Hence <samp data-coord="regex.umt:99:78">/hello\\/</samp> is a regex matching the string <samp data-coord="regex.umt:99:121">"hello"</samp>
followed by a <samp data-coord="regex.umt:99:149">\</samp> character.
</p></li><li data-coord="regex.umt:103:0"><p data-coord="regex.umt:103:4">Within a character class the usual meta-characters loose their
meaning and do not need to be escaped; the only characters which
are special are the range operator <samp data-coord="regex.umt:103:175">-</samp> (though not at the start),
and the negated character class operator <samp data-coord="regex.umt:103:251">^</samp> (only at the start) and
<samp data-coord="regex.umt:103:283">\</samp> for escaping.
</p></li></ul></section><section class="umt-slide" data-coord="regex.umt:110:0"><h2 data-coord="regex.umt:110:0">More Regex Examples</h2><dl data-coord="regex.umt:114:0"><dt data-coord="regex.umt:114:1"> <samp data-coord="regex.umt:114:1">/[1-9][0-9]*|0/</samp> </dt><dd data-coord="regex.umt:115:0"><p data-coord="regex.umt:115:3">Matches an integer with no non-significant leading zeros.
</p></dd><dt data-coord="regex.umt:117:1"> <samp data-coord="regex.umt:117:1">/[-+]?[0-9]+/</samp> </dt><dd data-coord="regex.umt:118:0"><p data-coord="regex.umt:118:3">Matches an integer with an optional sign (no restriction
on leading zeros).
</p></dd><dt data-coord="regex.umt:121:1"> <samp data-coord="regex.umt:121:1">/[0-9]+[lL]?/</samp> </dt><dd data-coord="regex.umt:122:0"><p data-coord="regex.umt:122:3">Matches an integer with an optional suffix of <samp data-coord="regex.umt:122:49">l</samp> of <samp data-coord="regex.umt:122:56">L</samp> (no restriction
on leading zeros).
</p></dd><dt data-coord="regex.umt:125:1"> <samp data-coord="regex.umt:125:1">/[a-zA-Z_][a-zA-Z0-9_]*/</samp> </dt><dd data-coord="regex.umt:126:0"><p data-coord="regex.umt:126:3">Matches the definition of an <em data-coord="regex.umt:126:32">identifier</em> in many programming languages.
An identifier consists of one or more alphanumeric characters or underscores
with the restriction that the first character cannot be a digit.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:131:0"><h2 data-coord="regex.umt:131:0">String <samp data-coord="regex.umt:131:7">search()</samp> Method</h2><p data-coord="regex.umt:134:1">Invoking <samp data-coord="regex.umt:134:10">search(</samp><em data-coord="regex.umt:134:23">regex</em><samp data-coord="regex.umt:134:34">)</samp> on a string will return the index
of the start of the first match of <em data-coord="regex.umt:134:108">regex</em> in the string; -1 if not found.
</p><pre><span class="hl opt">&gt;</span> <span class="hl str">&quot;abcd123&quot;</span><span class="hl opt">.</span><span class="hl kwd">search</span><span class="hl opt">(</span><span class="hl kwc">/[a-z]+[0-9]+/</span><span class="hl opt">)</span>
<span class="hl num">0</span>
<span class="hl opt">&gt;</span> <span class="hl str">&quot;+-abcd123&quot;</span><span class="hl opt">.</span><span class="hl kwd">search</span><span class="hl opt">(</span><span class="hl kwc">/[a-z]+[0-9]+/</span><span class="hl opt">)</span>
<span class="hl num">2</span>
<span class="hl opt">&gt;</span> <span class="hl str">&quot;+-abcd&quot;</span><span class="hl opt">.</span><span class="hl kwd">search</span><span class="hl opt">(</span><span class="hl kwc">/[a-z]+[0-9]+/</span><span class="hl opt">)</span>
<span class="hl opt">-</span><span class="hl num">1</span></pre></section><section class="umt-slide" data-coord="regex.umt:147:0"><h2 data-coord="regex.umt:147:0">String <samp data-coord="regex.umt:147:7">match()</samp> Method</h2><p data-coord="regex.umt:150:0">Invoking <samp data-coord="regex.umt:150:9">match(</samp><em data-coord="regex.umt:150:17">regex</em><samp data-coord="regex.umt:150:24">)</samp> on a string results in an "array":
</p><ul data-coord="regex.umt:152:0"><li data-coord="regex.umt:152:0"><p data-coord="regex.umt:152:4">Element 0 contains the entire match.
</p></li><li data-coord="regex.umt:154:0"><p data-coord="regex.umt:154:4">Elements \(n\) for \(n > 0\) contains the substring matched by
the \(n\)'th <strong data-coord="regex.umt:154:81">capturing parentheses</strong> group.
</p></li><li data-coord="regex.umt:157:0"><p data-coord="regex.umt:157:4">An <samp data-coord="regex.umt:157:7">index</samp> property contains the index of the
start of the match in the input string.
</p></li><li data-coord="regex.umt:160:0"><p data-coord="regex.umt:160:4">An <samp data-coord="regex.umt:160:7">input</samp> property contains the input string.
</p></li></ul></section><section class="umt-slide" data-coord="regex.umt:162:0"><h2 data-coord="regex.umt:162:0">String <samp data-coord="regex.umt:162:7">match()</samp> Examples</h2><pre><span class="hl opt">&gt;</span> <span class="hl str">&quot;abc123&quot;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/[a-z]+[0-9]+/</span><span class="hl opt">)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;abc123&apos;</span><span class="hl opt">,</span> index<span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">:</span> <span class="hl str">&apos;abc123&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt;</span> <span class="hl str">&quot;abc123&quot;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/([a-z]+)([0-9]+)/</span><span class="hl opt">)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;abc123&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;abc&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;123&apos;</span><span class="hl opt">,</span> index<span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">:</span> <span class="hl str">&apos;abc123&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt;</span> <span class="hl str">&quot;+-/abc123&quot;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(/([</span>a<span class="hl opt">-</span>z<span class="hl opt">]+)([</span><span class="hl num">0</span><span class="hl opt">-</span><span class="hl num">9</span><span class="hl opt">]+)/)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;abc123&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;abc&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;123&apos;</span><span class="hl opt">,</span> index<span class="hl opt">:</span> <span class="hl num">3</span><span class="hl opt">,</span> input<span class="hl opt">:</span> <span class="hl str">&apos;+-/abc123&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt;</span> <span class="hl str">&quot;+-abc123&quot;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/(([\-\+])[a-z]+)([0-9]+)/</span><span class="hl opt">)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;-abc123&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;-abc&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;-&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;123&apos;</span><span class="hl opt">,</span> index<span class="hl opt">:</span> <span class="hl num">1</span><span class="hl opt">,</span> input<span class="hl opt">:</span> <span class="hl str">&apos;+-abc123&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt; [,</span> a<span class="hl opt">,</span> b<span class="hl opt">] =</span> <span class="hl slc">//destructuring</span>
   <span class="hl str">&apos;abc3-123&apos;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/(\w+)\-(\d+)/</span><span class="hl opt">)</span> 
<span class="hl opt">[</span> <span class="hl str">&apos;abc3-123&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;abc3&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;123&apos;</span><span class="hl opt">,</span> index<span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">,</span>
  input<span class="hl opt">:</span> <span class="hl str">&apos;abc3-123&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt; [</span>a<span class="hl opt">,</span> b<span class="hl opt">]</span>
<span class="hl opt">[</span> <span class="hl str">&apos;abc3&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;123&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt;</span></pre></section><section class="umt-slide" data-coord="regex.umt:185:0"><h2 data-coord="regex.umt:185:0">String <samp data-coord="regex.umt:185:7">split()</samp> Method</h2><p data-coord="regex.umt:188:0">Can split a string on a regex:
</p><pre><span class="hl opt">&gt;</span> <span class="hl str">&quot;ab, x12, de , f&quot;</span><span class="hl opt">.</span><span class="hl kwd">split</span><span class="hl opt">(/ +/)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;ab,&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;x12,&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;de&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;,&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;f&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt;</span> <span class="hl str">&quot;ab, x12, de , f&quot;</span><span class="hl opt">.</span><span class="hl kwd">split</span><span class="hl opt">(/ *,</span> */<span class="hl opt">)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;ab&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;x12&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;de&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;f&apos;</span> <span class="hl opt">]</span></pre></section><section class="umt-slide" data-coord="regex.umt:198:0"><h2 data-coord="regex.umt:198:0">More Regex Syntax</h2><p data-coord="regex.umt:201:0"><samp data-coord="regex.umt:201:0">[a-z]</samp> not portable as it depends on the character codes for
lowercase characters being adjacent in the underlying character set.
True in ASCII, but for example, in EBCDIC alphabetic character codes
are not contiguous.
</p><dl data-coord="regex.umt:206:0"><dt data-coord="regex.umt:206:2"> <strong data-coord="regex.umt:206:1">Digit Char</strong> <samp data-coord="regex.umt:206:14">/\d/</samp> </dt><dd data-coord="regex.umt:207:0"><p data-coord="regex.umt:207:4">A regular expression which matches any digit.
</p></dd><dt data-coord="regex.umt:209:2"> <strong data-coord="regex.umt:209:1">Non-Digit Char</strong> <samp data-coord="regex.umt:209:18">/\D/</samp> </dt><dd data-coord="regex.umt:210:0"><p data-coord="regex.umt:210:4">A regular expression which matches any non-digit.
</p></dd><dt data-coord="regex.umt:212:2"> <strong data-coord="regex.umt:212:1">Word Char</strong> <samp data-coord="regex.umt:212:13">/\w/</samp> </dt><dd data-coord="regex.umt:213:0"><p data-coord="regex.umt:213:4">A regular expression which matches any word-char (alphanumeric or
<samp data-coord="regex.umt:213:74">_</samp>).
</p></dd><dt data-coord="regex.umt:216:2"> <strong data-coord="regex.umt:216:1">Non-Word Char</strong> <samp data-coord="regex.umt:216:17">/\W/</samp> </dt><dd data-coord="regex.umt:217:0"><p data-coord="regex.umt:217:4">A regular expression which matches any non-word-char.
</p></dd><dt data-coord="regex.umt:219:2"> <strong data-coord="regex.umt:219:1">Space Char</strong> <samp data-coord="regex.umt:219:14">/\s/</samp> </dt><dd data-coord="regex.umt:220:0"><p data-coord="regex.umt:220:4">A regular expression which matches any whitespace character
(blank, tab, newline etc.).
</p></dd><dt data-coord="regex.umt:223:2"> <strong data-coord="regex.umt:223:1">Non-Space Char</strong> <samp data-coord="regex.umt:223:18">/\S/</samp> </dt><dd data-coord="regex.umt:224:0"><p data-coord="regex.umt:224:4">A regular expression which matches any non-whitespace character.
</p></dd><dt data-coord="regex.umt:226:2"> <strong data-coord="regex.umt:226:1">Any char other than newline</strong> <samp data-coord="regex.umt:226:31">/./</samp> </dt><dd data-coord="regex.umt:227:0"><p data-coord="regex.umt:227:4">Matches any character other than newline.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:230:0"><h2 data-coord="regex.umt:230:0">Fixed Count or Range Count Quantifiers</h2><dl data-coord="regex.umt:233:0"><dt data-coord="regex.umt:233:2"> <samp data-coord="regex.umt:233:1">/\d{5}/</samp> </dt><dd data-coord="regex.umt:234:0"><p data-coord="regex.umt:234:4">Matches exactly 5 digits.  Suffix <samp data-coord="regex.umt:234:38">{</samp><em data-coord="regex.umt:234:45">n</em><samp data-coord="regex.umt:234:52">}</samp> means match
exactly <em data-coord="regex.umt:234:80">n</em> occurrences of preceeding regex.
</p></dd><dt data-coord="regex.umt:237:2"> <samp data-coord="regex.umt:237:1">/\d{5,}/</samp> </dt><dd data-coord="regex.umt:238:0"><p data-coord="regex.umt:238:4">Matches at least 5 digits.  Suffix <samp data-coord="regex.umt:238:39">{</samp><em data-coord="regex.umt:238:46">n</em><samp data-coord="regex.umt:238:53">,}</samp> means match
at least <em data-coord="regex.umt:238:83">n</em> occurrences of preceeding regex.
</p></dd><dt data-coord="regex.umt:241:2"> <samp data-coord="regex.umt:241:1">/\d{2,5}/</samp> </dt><dd data-coord="regex.umt:242:0"><p data-coord="regex.umt:242:4">Matches 2 - 5 digits.  Suffix <samp data-coord="regex.umt:242:34">{</samp><em data-coord="regex.umt:242:41">n</em><samp data-coord="regex.umt:242:48">,</samp><em data-coord="regex.umt:242:55">m</em><samp data-coord="regex.umt:242:62">}</samp>
means match <em data-coord="regex.umt:242:82">n</em> through <em data-coord="regex.umt:242:94">m</em> occurrences of preceeding regex.
</p></dd><dt data-coord="regex.umt:245:2"> <samp data-coord="regex.umt:245:1">/[a-zA-Z_]\w{0,7}/</samp> </dt><dd data-coord="regex.umt:246:0"><p data-coord="regex.umt:246:4">Matches an identifer containing upto 8 characters.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:249:0"><h2 data-coord="regex.umt:249:0">Context Regex Syntax</h2><p data-coord="regex.umt:252:0">Does not actually match anything, just provides a <strong data-coord="regex.umt:252:50">context</strong> for
other regex's to match.  Often known as  <strong data-coord="regex.umt:252:105">anchor</strong>'s
</p><dl data-coord="regex.umt:255:0"><dt data-coord="regex.umt:255:2"> <samp data-coord="regex.umt:255:1">/^\d/</samp> </dt><dd data-coord="regex.umt:256:0"><p data-coord="regex.umt:256:4">Matches a digit but only at the start of the input string.
Can be set to match at start of a line if <samp data-coord="regex.umt:256:109">m</samp> flag set.
</p></dd><dt data-coord="regex.umt:259:2"> <samp data-coord="regex.umt:259:1">/\d$/</samp> </dt><dd data-coord="regex.umt:260:0"><p data-coord="regex.umt:260:4">Matches a digit but only at the end of the input string.
Can be set to match at end of a line if <samp data-coord="regex.umt:260:105">m</samp> flag set.
</p></dd><dt data-coord="regex.umt:263:2"> <samp data-coord="regex.umt:263:1">/\bm/</samp> </dt><dd data-coord="regex.umt:264:0"><p data-coord="regex.umt:264:4">Matches a <samp data-coord="regex.umt:264:14">m</samp> but only on a word boundary.  Hence it will
match only the first <samp data-coord="regex.umt:264:87">m</samp> in the word <samp data-coord="regex.umt:264:103">"mommy"</samp>.
</p></dd><dt data-coord="regex.umt:267:2"> <samp data-coord="regex.umt:267:1">/\Bm/</samp> </dt><dd data-coord="regex.umt:268:0"><p data-coord="regex.umt:268:4">Matches a <samp data-coord="regex.umt:268:14">m</samp> which is <strong data-coord="regex.umt:268:27">not</strong> on a word boundary.  Hence it will
match only the internal <samp data-coord="regex.umt:268:96">m</samp>'s in the word <samp data-coord="regex.umt:268:114">"mommy"</samp>.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:272:0"><h2 data-coord="regex.umt:272:0">More on Capturing Groups</h2><dl data-coord="regex.umt:276:0"><dt data-coord="regex.umt:276:2"> <strong data-coord="regex.umt:276:1">Non-capturing Group</strong> <samp data-coord="regex.umt:276:23">/(?:\s|\w)\d+/</samp></dt><dd data-coord="regex.umt:277:0"><p data-coord="regex.umt:277:4">Just like <samp data-coord="regex.umt:277:14">/(\s|\w)\d+/</samp> but <samp data-coord="regex.umt:277:33">(?: )</samp>parentheses are
non-capturing.
</p></dd><dt data-coord="regex.umt:280:2"> <strong data-coord="regex.umt:280:1">Named Group</strong> <samp data-coord="regex.umt:280:15">/(?:\s|\w)(?&lt;num&gt;\d+)/</samp> </dt><dd data-coord="regex.umt:281:0"><p data-coord="regex.umt:281:4">Captures <samp data-coord="regex.umt:281:13">\d+</samp> into <samp data-coord="regex.umt:281:24">groups.num</samp>.
</p></dd></dl><pre><span class="hl opt">&gt;</span> <span class="hl str">&apos;abc123&apos;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/(?:\s|\w)(?&lt;num&gt;\d+)/</span><span class="hl opt">).</span>groups 
<span class="hl opt">[</span>Object<span class="hl opt">:</span> <span class="hl kwa">null prototype</span><span class="hl opt">] {</span> num<span class="hl opt">:</span> <span class="hl str">&apos;123&apos;</span> <span class="hl opt">}</span>
<span class="hl opt">&gt;</span> </pre></section><section class="umt-slide" data-coord="regex.umt:291:0"><h2 data-coord="regex.umt:291:0">Non-Greedy Quantifiers</h2><p data-coord="regex.umt:294:0">Normal quantifiers are greedy and attempt to match maximal text.  Make
quantifier <strong data-coord="regex.umt:294:82">non-greedy</strong> or <strong data-coord="regex.umt:294:98">lazy</strong> by suffixing quantifier with a <samp data-coord="regex.umt:294:136">?</samp>.
</p><pre><span class="hl opt">&gt;</span> <span class="hl str">&apos;abc123&apos;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/(\w*)(\d+)/</span><span class="hl opt">).</span><span class="hl kwd">slice</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;abc12&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;3&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt;</span> <span class="hl str">&apos;abc123&apos;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/(\w*?)(\d+)/</span><span class="hl opt">).</span><span class="hl kwd">slice</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">)</span>
<span class="hl opt">[</span> <span class="hl str">&apos;abc&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;123&apos;</span> <span class="hl opt">]</span>
<span class="hl opt">&gt;</span>
<span class="hl opt">&gt;</span> <span class="hl str">&apos;&lt;a&gt; &lt;b&gt;&apos;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/\&lt;.*\&gt;/</span><span class="hl opt">)[</span><span class="hl num">0</span><span class="hl opt">]</span>
<span class="hl str">&apos;&lt;a&gt; &lt;b&gt;&apos;</span>
<span class="hl opt">&gt;</span> <span class="hl str">&apos;&lt;a&gt; &lt;b&gt;&apos;</span><span class="hl opt">.</span><span class="hl kwd">match</span><span class="hl opt">(</span><span class="hl kwc">/\&lt;.*?\&gt;/</span><span class="hl opt">)[</span><span class="hl num">0</span><span class="hl opt">]</span>
<span class="hl str">&apos;&lt;a&gt;&apos;</span>
<span class="hl opt">&gt;</span></pre></section><section class="umt-slide" data-coord="regex.umt:310:0"><h2 data-coord="regex.umt:310:0"><samp data-coord="regex.umt:310:0">RegExp()</samp> Constructor</h2><ul data-coord="regex.umt:313:0"><li data-coord="regex.umt:313:0"><p data-coord="regex.umt:313:4">Constructor constructs a regex from a string.
</p></li><li data-coord="regex.umt:315:0"><p data-coord="regex.umt:315:4">Can be used to build dynamic regex's depending on a variable.
</p></li><li data-coord="regex.umt:317:0"><p data-coord="regex.umt:317:4">Suffers from <em data-coord="regex.umt:317:17">backslashitis</em>.
</p></li></ul><pre><span class="hl opt">&gt;</span> <span class="hl kwa">new</span> <span class="hl kwd">RegExp</span><span class="hl opt">(</span><span class="hl str">&apos;[abc]&apos;</span><span class="hl opt">)</span>
<span class="hl kwc">/[abc]/</span>
<span class="hl opt">&gt;</span> someVar <span class="hl opt">=</span> <span class="hl str">&apos;x&apos;</span>
<span class="hl str">&apos;x&apos;</span>
<span class="hl opt">&gt;</span> <span class="hl kwa">new</span> <span class="hl kwd">RegExp</span><span class="hl opt">(</span><span class="hl str">`</span><span class="hl ipl">${someVar}</span><span class="hl str"></span><span class="hl esc">\\</span><span class="hl str">d`</span><span class="hl opt">)</span>
<span class="hl kwc">/x\d/</span>
<span class="hl opt">&gt;</span> <span class="hl kwa">new</span> <span class="hl kwd">RegExp</span><span class="hl opt">(</span><span class="hl str">`</span><span class="hl ipl">${someVar}</span><span class="hl str"></span><span class="hl esc">\\\\\\</span><span class="hl str">d`</span><span class="hl opt">)</span>
<span class="hl kwc">/x\\\d/</span>
<span class="hl opt">&gt;</span></pre></section><section class="umt-slide" data-coord="regex.umt:331:0"><h2 data-coord="regex.umt:331:0">More Regex Examples</h2><dl data-coord="regex.umt:334:0"><dt data-coord="regex.umt:334:2"> <samp data-coord="regex.umt:334:1">/\d{1,3}(?:\.\d{1,3}){3}/</samp> </dt><dd data-coord="regex.umt:335:0"><p data-coord="regex.umt:335:4">An IPv4 internet address.  Consists of 4 decimal numbers each
containing up to 3 digits, separated by <samp data-coord="regex.umt:335:110">.</samp> characters.
</p></dd><dt data-coord="regex.umt:338:2"> <samp data-coord="regex.umt:338:1">/\/\/.*/</samp> </dt><dd data-coord="regex.umt:339:0"><p data-coord="regex.umt:339:4">A JavaScript single-line comment. 2 forward slashes followed by
zero-or-more characters other than newline.
</p></dd><dt data-coord="regex.umt:342:2"> <samp data-coord="regex.umt:342:1">/[-+]?\d+(?:\.\d+)?(?:[eE][-+]?\d+)?/</samp> </dt><dd data-coord="regex.umt:343:0"><p data-coord="regex.umt:343:4">An optionally signed integer or floating point literal.  The integer
part must be present.  It may be optionally followed by a fraction
part which consists of a decimal point followed by one-or-more
digits.  That too may optionally be followed by an exponent part which
consists of either an <samp data-coord="regex.umt:343:312">e</samp> or an <samp data-coord="regex.umt:343:322">E</samp> followed by an optional sign,
followed by one-or-more digits.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:350:0"><h2 data-coord="regex.umt:350:0">Regex Flags</h2><p data-coord="regex.umt:353:0">Specify flags after closing slash when using literal syntax or as a
string second argument to <samp data-coord="regex.umt:353:94">RegExp()</samp> constructor:
</p><dl data-coord="regex.umt:356:0"><dt data-coord="regex.umt:356:2"> <samp data-coord="regex.umt:356:1">/hello/i</samp> </dt><dd data-coord="regex.umt:357:0"><p data-coord="regex.umt:357:4">Case-insensitive.  Equivalent to <samp data-coord="regex.umt:357:37">[hH][eE][lL][lL][oO]</samp>.
</p></dd><dt data-coord="regex.umt:359:2"> <samp data-coord="regex.umt:359:1">/hello/g</samp> </dt><dd data-coord="regex.umt:360:0"><p data-coord="regex.umt:360:4">Global search.  Start search from index of last match
of this regex in string.
</p></dd><dt data-coord="regex.umt:363:2"> <samp data-coord="regex.umt:363:1">/^\#.*$/m</samp> </dt><dd data-coord="regex.umt:364:0"><p data-coord="regex.umt:364:4">Multiline flag changes <samp data-coord="regex.umt:364:27">^</samp> and <samp data-coord="regex.umt:364:35">$</samp> to match only at the
start/end of a <strong data-coord="regex.umt:364:79">line</strong>.
</p><p data-coord="regex.umt:367:4">Example gives a single-line comment starting with a <samp data-coord="regex.umt:367:56">#</samp>-character
in column 1 at the start of a line and continuing until the end of
the line.
</p></dd></dl><p data-coord="regex.umt:371:0">Unfortunately, no way to include ignored formatting whitespace within
regex like the <strong data-coord="regex.umt:371:85">verbose</strong> <samp data-coord="regex.umt:371:95">/x</samp> flag available in other languages like
Python or Ruby.
</p></section><section class="umt-slide" data-coord="regex.umt:375:0"><h2 data-coord="regex.umt:375:0">String <samp data-coord="regex.umt:375:7">matchAll()</samp> Method</h2><p data-coord="regex.umt:378:0">Like <samp data-coord="regex.umt:378:5">match()</samp>, but returns iterator over <strong data-coord="regex.umt:378:42">all</strong> matches.  Must use
global <samp data-coord="regex.umt:378:74">g</samp> flag.
</p><pre><span class="hl opt">&gt;</span> <span class="hl str">&apos; prj1, hw2 ## #quiz1 &apos;</span><span class="hl opt">.</span>
  <span class="hl kwd">matchAll</span><span class="hl opt">(</span><span class="hl kwc">/(?&lt;x&gt;\w+?)(?&lt;y&gt;\d+)/g</span><span class="hl opt">)</span>
Object <span class="hl opt">[</span>RegExp String Iterator<span class="hl opt">] {}</span>
<span class="hl opt">&gt; [ ...</span> <span class="hl str">&apos; prj1, hw2 ## #quiz1 &apos;</span><span class="hl opt">.</span>
  <span class="hl kwd">matchAll</span><span class="hl opt">(</span><span class="hl kwc">/(?&lt;x&gt;\w+?)(?&lt;y&gt;\d+)/g</span><span class="hl opt">)  ].</span>
  <span class="hl kwd">map</span><span class="hl opt">(</span>x <span class="hl opt">=&gt;</span> x<span class="hl opt">.</span>groups<span class="hl opt">)</span>
<span class="hl opt">[</span>
  <span class="hl opt">[</span>Object<span class="hl opt">:</span> <span class="hl kwa">null prototype</span><span class="hl opt">] {</span> x<span class="hl opt">:</span> <span class="hl str">&apos;prj&apos;</span><span class="hl opt">,</span> y<span class="hl opt">:</span> <span class="hl str">&apos;1&apos;</span> <span class="hl opt">},</span>
  <span class="hl opt">[</span>Object<span class="hl opt">:</span> <span class="hl kwa">null prototype</span><span class="hl opt">] {</span> x<span class="hl opt">:</span> <span class="hl str">&apos;hw&apos;</span><span class="hl opt">,</span> y<span class="hl opt">:</span> <span class="hl str">&apos;2&apos;</span> <span class="hl opt">},</span>
  <span class="hl opt">[</span>Object<span class="hl opt">:</span> <span class="hl kwa">null prototype</span><span class="hl opt">] {</span> x<span class="hl opt">:</span> <span class="hl str">&apos;quiz&apos;</span><span class="hl opt">,</span> y<span class="hl opt">:</span> <span class="hl str">&apos;1&apos;</span> <span class="hl opt">}</span>
<span class="hl opt">]</span>
<span class="hl opt">&gt;</span> </pre></section><section class="umt-slide" data-coord="regex.umt:397:0"><h2 data-coord="regex.umt:397:0">String <samp data-coord="regex.umt:397:7">replace()</samp> Method</h2><pre data-coord="regex.umt:401:0">string.replace(regex|substr, replacement|function)
</pre><p data-coord="regex.umt:404:0"><samp data-coord="regex.umt:404:0">replacement</samp> can contain:
</p><dl data-coord="regex.umt:406:0"><dt data-coord="regex.umt:406:2"> <samp data-coord="regex.umt:406:1">$$</samp> </dt><dd data-coord="regex.umt:407:0"><p data-coord="regex.umt:407:4">Inserts a <samp data-coord="regex.umt:407:14">$</samp>.
</p></dd><dt data-coord="regex.umt:409:2"> <samp data-coord="regex.umt:409:1">$&amp;</samp> </dt><dd data-coord="regex.umt:410:0"><p data-coord="regex.umt:410:4">Inserts match.
</p></dd><dt data-coord="regex.umt:412:2"> <samp data-coord="regex.umt:412:1">$`</samp> </dt><dd data-coord="regex.umt:413:0"><p data-coord="regex.umt:413:4">Inserts portion of <samp data-coord="regex.umt:413:23">string</samp> before match.
</p></dd><dt data-coord="regex.umt:415:2"> <samp data-coord="regex.umt:415:1">$'</samp> </dt><dd data-coord="regex.umt:416:0"><p data-coord="regex.umt:416:4">Inserts portion of <samp data-coord="regex.umt:416:23">string</samp> after match.
</p></dd><dt data-coord="regex.umt:418:2"> <samp data-coord="regex.umt:418:1">$</samp><em data-coord="regex.umt:418:8">n</em> </dt><dd data-coord="regex.umt:419:0"><p data-coord="regex.umt:419:4">Inserts text matched by <em data-coord="regex.umt:419:28">n</em>'th capturing parentheses in <samp data-coord="regex.umt:419:60">regex</samp>.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:422:0"><h2 data-coord="regex.umt:422:0">String <samp data-coord="regex.umt:422:7">replace()</samp> Examples</h2><pre><span class="hl opt">&gt;</span> <span class="hl str">&apos;the dog&apos;</span><span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl str">&apos;dog&apos;</span><span class="hl opt">,</span> <span class="hl str">&apos;cat&apos;</span><span class="hl opt">)</span>
<span class="hl str">&apos;the cat&apos;</span>
<span class="hl opt">&gt;</span> <span class="hl str">&apos;the Dog&apos;</span><span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl kwc">/dog/i</span><span class="hl opt">,</span> <span class="hl str">&apos;cat&apos;</span><span class="hl opt">)</span>
<span class="hl str">&apos;the cat&apos;</span>
<span class="hl opt">&gt;</span> <span class="hl str">&apos;the dog&apos;</span><span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl kwc">/[aeiou]/</span><span class="hl opt">,</span> <span class="hl str">&apos;&apos;</span><span class="hl opt">)</span>
<span class="hl str">&apos;th dog&apos;</span>
<span class="hl opt">&gt;</span> <span class="hl str">&apos;the dog&apos;</span><span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl kwc">/[aeiou]/g</span><span class="hl opt">,</span> <span class="hl str">&apos;&apos;</span><span class="hl opt">)</span>
<span class="hl str">&apos;th dg&apos;</span>
<span class="hl opt">&gt;</span> <span class="hl str">&apos;the dog123 fido; cat99 eve&apos;</span><span class="hl opt">.</span>
    <span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl kwc">/([^\d\s]+)(\d+)/g</span><span class="hl opt">,</span> <span class="hl str">&apos;$1-$2&apos;</span><span class="hl opt">)</span>
<span class="hl str">&apos;the dog-123 fido; cat-99 eve&apos;</span></pre></section><section class="umt-slide" data-coord="regex.umt:439:0"><h2 data-coord="regex.umt:439:0">String <samp data-coord="regex.umt:439:7">replace()</samp> Examples Continued</h2><pre><span class="hl opt">&gt;</span> <span class="hl str">&apos;0 cats, 1 cat, 7 cats&apos;</span><span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl kwc">/\d+/</span><span class="hl opt">,</span>
     <span class="hl kwa">function</span><span class="hl opt">(</span>match<span class="hl opt">) {</span>
       <span class="hl kwa">const</span> n <span class="hl opt">=</span> <span class="hl kwd">Number</span><span class="hl opt">(</span>match<span class="hl opt">);</span>
       <span class="hl kwa">if</span> <span class="hl opt">(</span>n <span class="hl opt">===</span> <span class="hl num">0</span><span class="hl opt">) {</span>
         <span class="hl kwa">return</span> <span class="hl str">&apos;zero&apos;</span><span class="hl opt">;</span>
       <span class="hl opt">}</span>
       <span class="hl kwa">else if</span> <span class="hl opt">(</span>n <span class="hl opt">===</span> <span class="hl num">1</span><span class="hl opt">) {</span>
         <span class="hl kwa">return</span> <span class="hl str">&apos;one&apos;</span><span class="hl opt">;</span>
       <span class="hl opt">}</span>
       <span class="hl kwa">else</span> <span class="hl opt">{</span>
         <span class="hl kwa">return</span> <span class="hl str">&apos;many&apos;</span><span class="hl opt">;</span>
       <span class="hl opt">}</span>
   <span class="hl opt">})</span>
<span class="hl str">&apos;zero cats, 1 cat, 7 cats&apos;</span>
<span class="hl opt">&gt;</span></pre></section><section class="umt-slide" data-coord="regex.umt:460:0"><h2 data-coord="regex.umt:460:0">String <samp data-coord="regex.umt:460:7">replace()</samp> Examples Continued</h2><pre><span class="hl opt">&gt;</span> <span class="hl str">&apos;0 cats, 1 cat, 7 cats&apos;</span><span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl kwc">/\d+/g</span><span class="hl opt">,</span>
     <span class="hl kwa">function</span><span class="hl opt">(</span>match<span class="hl opt">) {</span>
       <span class="hl kwa">const</span> n <span class="hl opt">=</span> <span class="hl kwd">Number</span><span class="hl opt">(</span>match<span class="hl opt">);</span>
       <span class="hl kwa">if</span> <span class="hl opt">(</span>n <span class="hl opt">===</span> <span class="hl num">0</span><span class="hl opt">) {</span>
         <span class="hl kwa">return</span> <span class="hl str">&apos;zero&apos;</span><span class="hl opt">;</span>
       <span class="hl opt">}</span>
       <span class="hl kwa">else if</span> <span class="hl opt">(</span>n <span class="hl opt">===</span> <span class="hl num">1</span><span class="hl opt">) {</span>
         <span class="hl kwa">return</span> <span class="hl str">&apos;one&apos;</span><span class="hl opt">;</span>
       <span class="hl opt">}</span>
       <span class="hl kwa">else</span> <span class="hl opt">{</span>
         <span class="hl kwa">return</span> <span class="hl str">&apos;many&apos;</span><span class="hl opt">;</span>
       <span class="hl opt">}</span>
   <span class="hl opt">})</span>
<span class="hl str">&apos;zero cats, one cat, many cats&apos;</span>
<span class="hl opt">&gt;</span></pre></section><section class="umt-slide" data-coord="regex.umt:481:0"><h2 data-coord="regex.umt:481:0"><samp data-coord="regex.umt:481:0">RegExp</samp> Methods</h2><dl data-coord="regex.umt:485:0"><dt data-coord="regex.umt:485:2"> <samp data-coord="regex.umt:485:1">exec(str)</samp> </dt><dd data-coord="regex.umt:486:0"><p data-coord="regex.umt:486:4">Searches for match of this in String <samp data-coord="regex.umt:486:41">str</samp>.  Return value
similar to <samp data-coord="regex.umt:486:77">String.prototype.match()</samp>.
</p></dd><dt data-coord="regex.umt:489:2"> <samp data-coord="regex.umt:489:1">test(str)</samp> </dt><dd data-coord="regex.umt:490:0"><p data-coord="regex.umt:490:4">Searches for match of this in String <samp data-coord="regex.umt:490:41">str</samp>.  Returns
<samp data-coord="regex.umt:490:61">true</samp> if search successful, <samp data-coord="regex.umt:490:90">false</samp> otherwise.
</p></dd></dl></section><section class="umt-slide" data-coord="regex.umt:494:0"><h2 data-coord="regex.umt:494:0">RegExp Limitations</h2><ul data-coord="regex.umt:497:0"><li data-coord="regex.umt:497:0"><p data-coord="regex.umt:497:4">Standard regular expressions cannot be used to recognize
nested constructs for an arbitrary nesting depth.
</p></li><li data-coord="regex.umt:500:0"><p data-coord="regex.umt:500:4">For example, it is not possible to write a regex for strings of
balanced parentheses like <samp data-coord="regex.umt:500:98">'((()))'</samp> for an arbitrary depth of
nesting.
</p></li><li data-coord="regex.umt:504:0"><p data-coord="regex.umt:504:4">Colloquially, regex's cannot <strong data-coord="regex.umt:504:33">count</strong>.
</p></li><li data-coord="regex.umt:506:0"><p data-coord="regex.umt:506:4">It is always possible to write a regex for a nested construct when
the maximum depth of nessing is bounded.  For example, all
strings of balanced parentheses of depth upto 2 can be
written by simply enumerating all possibilities:
</p><pre data-coord="regex.umt:512:0">    /( \( ( \(\) )* \) )*/
</pre><p data-coord="regex.umt:515:4">where the whitespace is used only for formatting and should be
ignored.
</p></li></ul></section><section class="umt-slide" data-coord="regex.umt:518:0"><h2 data-coord="regex.umt:518:0">Word Count Program: Log</h2><p data-coord="regex.umt:521:0">Print number of lines, words, chars in specified files; subset of
functionality of Unix <a href="https://www.freebsd.org/cgi/man.cgi?wc" data-coord="regex.umt:521:130">wc(1)</a>
program.
</p><p data-coord="regex.umt:525:0">Program shows use of regex:
</p><pre>$ <span class="hl kwc">wc wc</span>.js
  <span class="hl num">89  236 1774</span> <span class="hl kwc">wc</span>.js
$ .<span class="hl opt">/</span><span class="hl kwc">wc</span>.js <span class="hl kwc">wc</span>.js 
   <span class="hl num">89   236  1774</span> <span class="hl kwc">wc</span>.js
$ <span class="hl kwc">wc</span> <span class="hl opt">*</span>
   <span class="hl num">1    2   12</span> hello-world.txt
  <span class="hl num">89  236 1774</span> <span class="hl kwc">wc</span>.js
  <span class="hl num">90  238 1786</span> total
$ .<span class="hl opt">/</span><span class="hl kwc">wc</span>.js <span class="hl opt">*</span>
    <span class="hl num">1     2    12</span> hello-world.txt
   <span class="hl num">89   236  1774</span> <span class="hl kwc">wc</span>.js
   <span class="hl num">90   238  1786</span> total
$ </pre></section><section class="umt-slide" data-coord="regex.umt:544:0"><h2 data-coord="regex.umt:544:0">Word Count Program: <samp data-coord="regex.umt:544:20">Wc</samp> object</h2><p data-coord="regex.umt:547:0">In <a href="./code/wc.js?colorize=true" data-coord="regex.umt:547:33">wc.js:</a>
</p><pre>
<span class="hl kwa">const</span> OUT_WIDTH <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span> 

<span class="hl kwa">class</span> Wc <span class="hl opt">{</span>
  <span class="hl kwa">constructor</span> <span class="hl opt">(</span>nLines<span class="hl opt">,</span> nWords<span class="hl opt">,</span> nChars<span class="hl opt">) {</span>
    <span class="hl kwa">this</span><span class="hl opt">.</span>nLines <span class="hl opt">=</span> nLines <span class="hl opt">||</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl kwa">this</span><span class="hl opt">.</span>nWords <span class="hl opt">=</span> nWords <span class="hl opt">||</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl kwa">this</span><span class="hl opt">.</span>nChars <span class="hl opt">=</span> nChars <span class="hl opt">||</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>

  <span class="hl kwd">update</span><span class="hl opt">(</span>wc<span class="hl opt">) {</span>
    <span class="hl kwa">this</span><span class="hl opt">.</span>nLines <span class="hl opt">+=</span> wc<span class="hl opt">.</span>nLines<span class="hl opt">;</span>
    <span class="hl kwa">this</span><span class="hl opt">.</span>nWords <span class="hl opt">+=</span> wc<span class="hl opt">.</span>nWords<span class="hl opt">;</span>
    <span class="hl kwa">this</span><span class="hl opt">.</span>nChars <span class="hl opt">+=</span> wc<span class="hl opt">.</span>nChars<span class="hl opt">;</span>
  <span class="hl opt">}</span>
</pre></section><section class="umt-slide" data-coord="regex.umt:552:0"><h2 data-coord="regex.umt:552:0">Word Count Program: <samp data-coord="regex.umt:552:20">Wc toString()</samp></h2><pre>
  <span class="hl kwd">toString</span><span class="hl opt">() {</span>
    <span class="hl kwa">const</span> counts <span class="hl opt">=</span>
      <span class="hl opt">[</span><span class="hl kwa">this</span><span class="hl opt">.</span>nLines<span class="hl opt">,</span> <span class="hl kwa">this</span><span class="hl opt">.</span>nWords<span class="hl opt">,</span> <span class="hl kwa">this</span><span class="hl opt">.</span>nChars<span class="hl opt">];</span>
    <span class="hl kwa">let</span> str <span class="hl opt">=</span> <span class="hl str">&apos;&apos;</span><span class="hl opt">;</span>
    <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwa">let</span> count <span class="hl kwa">of</span> counts<span class="hl opt">) {</span>
      str <span class="hl opt">+=</span> <span class="hl kwd">String</span><span class="hl opt">(</span>count<span class="hl opt">).</span><span class="hl kwd">padStart</span><span class="hl opt">(</span>OUT_WIDTH<span class="hl opt">) +</span> <span class="hl str">&apos; &apos;</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">return</span> str<span class="hl opt">;</span>
  <span class="hl opt">}</span>

<span class="hl opt">}</span> <span class="hl slc">//class Wc</span>
</pre></section><section class="umt-slide" data-coord="regex.umt:558:0"><h2 data-coord="regex.umt:558:0">Word Count Program: <samp data-coord="regex.umt:558:20">wc()</samp> function</h2><pre>
<span class="hl kwa">function</span> <span class="hl kwd">wc</span><span class="hl opt">(</span>text<span class="hl opt">) {</span>
  <span class="hl kwa">let</span> nLines <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> nWords <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> nChars <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">//const re = /([ \t]+)|(\n+)|(\S+)/g;</span>
  <span class="hl kwa">const</span> re <span class="hl opt">=</span> <span class="hl kwc">/(\n+)|(\S+)|[^\S\n]+/g</span><span class="hl opt">;</span>
  <span class="hl kwa">let</span> match <span class="hl opt">=</span> <span class="hl kwa">null</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span> <span class="hl opt">((</span>match <span class="hl opt">=</span> re<span class="hl opt">.</span><span class="hl kwd">exec</span><span class="hl opt">(</span>text<span class="hl opt">)) !==</span> <span class="hl kwa">null</span><span class="hl opt">) {</span>
    nChars <span class="hl opt">+=</span> match<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">].</span>length<span class="hl opt">;</span>
    <span class="hl kwa">if</span> <span class="hl opt">(</span>match<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]) {</span>
      nLines <span class="hl opt">+=</span> match<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">].</span>length<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">else if</span> <span class="hl opt">(</span>match<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">]) {</span>
      <span class="hl opt">++</span>nWords<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> <span class="hl slc">//while</span>
  <span class="hl kwa">return new</span> <span class="hl kwd">Wc</span><span class="hl opt">(</span>nLines<span class="hl opt">,</span> nWords<span class="hl opt">,</span> nChars<span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre></section><section class="umt-slide" data-coord="regex.umt:563:0"><h2 data-coord="regex.umt:563:0">Word Count Program: <samp data-coord="regex.umt:563:20">wcFile()</samp> function</h2><pre><span class="hl slc">//return Wc object for fName</span>
<span class="hl kwa">function</span> <span class="hl kwd">wcFile</span><span class="hl opt">(</span>fName<span class="hl opt">) {</span>
  <span class="hl kwa">let</span> text<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    text <span class="hl opt">=</span> fs<span class="hl opt">.</span><span class="hl kwd">readFileSync</span><span class="hl opt">(</span>fName<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">catch</span> <span class="hl opt">(</span>err<span class="hl opt">) {</span>
    console<span class="hl opt">.</span><span class="hl kwd">error</span><span class="hl opt">(</span>err<span class="hl opt">);</span> process<span class="hl opt">.</span><span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> <span class="hl kwd">wc</span><span class="hl opt">(</span>text<span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre></section><section class="umt-slide" data-coord="regex.umt:568:0"><h2 data-coord="regex.umt:568:0">Word Count Program: <samp data-coord="regex.umt:568:20">main()</samp> function</h2><pre>
<span class="hl kwa">function</span> <span class="hl kwd">main</span><span class="hl opt">(</span>argv<span class="hl opt">) {</span>
  <span class="hl kwa">const</span> firstIndex <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span>
  <span class="hl kwa">const</span> count <span class="hl opt">=</span> argv<span class="hl opt">.</span>length <span class="hl opt">-</span> firstIndex<span class="hl opt">;</span>
  <span class="hl kwa">if</span> <span class="hl opt">(</span>count <span class="hl opt">&lt;=</span> <span class="hl num">0</span><span class="hl opt">) {</span> <span class="hl slc">//could read stdin instead of error</span>
    console<span class="hl opt">.</span><span class="hl kwd">error</span><span class="hl opt">(</span><span class="hl str">`usage:</span> <span class="hl ipl">${argv[1]}</span> <span class="hl str">FILE...`</span><span class="hl opt">);</span>
    process<span class="hl opt">.</span><span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">}</span></pre></section><section class="umt-slide" data-coord="regex.umt:574:0"><h2 data-coord="regex.umt:574:0">Word Count Program: <samp data-coord="regex.umt:574:20">main()</samp> function Continued</h2><pre>
  <span class="hl kwa">const</span> totals <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Wc</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwa">let</span> i <span class="hl opt">=</span> firstIndex<span class="hl opt">;</span> i <span class="hl opt">&lt;</span> argv<span class="hl opt">.</span>length<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwa">const</span> fName <span class="hl opt">=</span> argv<span class="hl opt">[</span>i<span class="hl opt">];</span>
    <span class="hl kwa">const</span> file_wc <span class="hl opt">=</span> <span class="hl kwd">wcFile</span><span class="hl opt">(</span>fName<span class="hl opt">);</span>
    console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span><span class="hl str">`</span><span class="hl ipl">${file_wc.toString()}${fName}</span><span class="hl str">`</span><span class="hl opt">);</span>
    totals<span class="hl opt">.</span><span class="hl kwd">update</span><span class="hl opt">(</span>file_wc<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">if</span> <span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">1</span><span class="hl opt">) {</span>
    console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span><span class="hl str">`</span><span class="hl ipl">${totals.toString()}</span><span class="hl str">total`</span><span class="hl opt">);</span>
  <span class="hl opt">};</span>
<span class="hl opt">}</span></pre></section><section class="umt-slide" data-coord="regex.umt:580:0"><h2 data-coord="regex.umt:580:0">References</h2><ul data-coord="regex.umt:584:0"><li data-coord="regex.umt:584:0"><p data-coord="regex.umt:584:4"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" data-coord="regex.umt:584:95">MDN</a>
</p></li><li data-coord="regex.umt:586:0"><p data-coord="regex.umt:586:4"><em data-coord="regex.umt:586:44"><a href="http://www.regular-expressions.info/" data-coord="regex.umt:586:44">Regular-Expressions.info</a></em>
</p></li><li data-coord="regex.umt:588:0"><p data-coord="regex.umt:588:4">Jeffrey E. F. Friedl, <em data-coord="regex.umt:588:26">Mastering Regular Expressions</em>, 3rd
Edition, O'Reilly, 2006.
</p></li></ul></section></section>
</div> <!-- #content -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="../../assets/scripts/slide-controls.js"></script>
<script src="../../assets/scripts/loginAction.js"></script>
</body>
</html>
